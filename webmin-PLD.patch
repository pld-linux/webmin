diff -uNr webmin-0.990.orig/apache/config-pld-linux webmin-0.990/apache/config-pld-linux
--- webmin-0.990.orig/apache/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/apache/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,7 @@
+show_list=0
+httpd_dir=/etc/httpd
+httpd_path=/usr/sbin/httpd
+mime_types=/etc/mime.types
+start_cmd=/etc/rc.d/init.d/httpd start
+stop_cmd=/etc/rc.d/init.d/httpd stop
+show_order=0
diff -uNr webmin-0.990.orig/bind8/config-pld-linux webmin-0.990/bind8/config-pld-linux
--- webmin-0.990.orig/bind8/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/bind8/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,5 @@
+soa_style=0
+named_path=/usr/sbin/named
+named_conf=/etc/named.conf
+show_list=0
+records_order=0
diff -uNr webmin-0.990.orig/config-pld-linux webmin-0.990/config-pld-linux
--- webmin-0.990.orig/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,6 @@
+find_pid_command=ps auwwwx | grep NAME | grep -v grep | awk '{ print $2 }'
+path=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin
+ld_env=LD_LIBRARY_PATH
+passwd_file=/etc/shadow
+passwd_uindex=0
+passwd_pindex=1
diff -uNr webmin-0.990.orig/cron/config-pld-linux webmin-0.990/cron/config-pld-linux
--- webmin-0.990.orig/cron/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/cron/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,12 @@
+cron_dir=/var/spool/cron
+cron_deny_file=/etc/cron/cron.deny
+cron_input=1
+cron_delete_command=crontab -u USER -r
+cron_edit_command=crontab -u USER -e
+vixie_cron=1
+cron_deny_all=2
+system_crontab=/etc/crontab
+cron_allow_file=/etc/cron.allow
+cron_get_command=crontab -u USER -l
+run_parts=run-parts
+cronfiles_dir=/etc/cron.d
diff -uNr webmin-0.990.orig/dhcpd/config-pld-linux webmin-0.990/dhcpd/config-pld-linux
--- webmin-0.990.orig/dhcpd/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/dhcpd/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,4 @@
+dhcpd_conf=/etc/dhcpd.conf
+pid_file=/var/run/dhcpd.pid
+dhcpd_path=/usr/sbin/dhcpd
+lease_file=/var/lib/dhcp/dhcpd.leases
diff -uNr webmin-0.990.orig/exports/config-pld-linux webmin-0.990/exports/config-pld-linux
--- webmin-0.990.orig/exports/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/exports/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,3 @@
+restart_command=/etc/rc.d/init.d/nfs restart
+exports_file=/etc/exports
+nfs_server=rpc.nfsd
diff -uNr webmin-0.990.orig/heartbeat/module.info webmin-0.990/heartbeat/module.info
--- webmin-0.990.orig/heartbeat/module.info	Mon Jul  1 07:04:42 2002
+++ webmin-0.990/heartbeat/module.info	Mon Jul  1 11:22:24 2002
@@ -1,6 +1,6 @@
 category=cluster
 depends=init 0.990
-os_support=msc-linux redhat-linux open-linux slackware-linux debian-linux suse-linux corel-linux turbo-linux cobalt-linux mandrake-linux debian-linux freebsd generic-linux
+os_support=msc-linux redhat-linux open-linux slackware-linux debian-linux suse-linux corel-linux turbo-linux cobalt-linux mandrake-linux debian-linux freebsd generic-linux pld-linux
 desc=Heartbeat Monitor
 version=0.990
 desc_ca=Monitor Heartbeat
diff -uNr webmin-0.990.orig/inetd/config-pld-linux webmin-0.990/inetd/config-pld-linux
--- webmin-0.990.orig/inetd/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/inetd/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,14 @@
+show_empty=1
+services_file=/etc/services
+extended_inetd=1
+restart_command=killall -HUP inetd || /etc/rc.d/init.d/rc-inetd start
+rpc_file=/etc/rpc
+protocols_file=/etc/protocols
+tcpd_path=/usr/sbin/tcpd
+rpc_inetd=1
+inetd_conf_file=/etc/inetd.conf
+rpc_protocols=tcp udp
+allow_file=/etc/tcpd/hosts.allow
+deny_file=/etc/tcpd/hosts.deny
+sort_mode=0
+ipv6=1
diff -uNr webmin-0.990.orig/init/config-pld-linux webmin-0.990/init/config-pld-linux
--- webmin-0.990.orig/init/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/init/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,13 @@
+soft_links=1
+show_opts=0
+init_base=/etc/rc.d
+init_dir=/etc/rc.d/init.d
+reboot_command=reboot
+shutdown_command=halt
+order_digits=2
+inittab_id=id
+extra_init=/etc/rc.d/rc.local
+chkconfig=2345
+subsys=/var/lock/subsys
+expert=0
+desc=1
diff -uNr webmin-0.990.orig/lpadmin/config-pld-linux webmin-0.990/lpadmin/config-pld-linux
--- webmin-0.990.orig/lpadmin/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/lpadmin/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,10 @@
+iface_perms=755
+printcap_file=/etc/printcap
+gs_lib=
+iface_arg=
+gs_path=gs
+spool_dir=/var/spool/lpd
+gs_fontpath=
+smbclient_path=smbclient
+print_style=linux
+driver_style=redhat
diff -uNr webmin-0.990.orig/lvm/module.info webmin-0.990/lvm/module.info
--- webmin-0.990.orig/lvm/module.info	Mon Jul  1 07:04:42 2002
+++ webmin-0.990/lvm/module.info	Mon Jul  1 11:22:58 2002
@@ -1,6 +1,6 @@
 category=hardware
 desc_zh_TW.Big5=邏輯管理系統
-os_support=redhat-linux mandrake-linux slackware-linux debian-linux suse-linux open-linux turbo-linux corel-linux cobalt-linux msc-linux generic-linux gentoo-linux
+os_support=redhat-linux mandrake-linux slackware-linux debian-linux suse-linux open-linux turbo-linux corel-linux cobalt-linux msc-linux generic-linux gentoo-linux pld-linux
 desc=Logical Volume Management
 name=LVM
 depends=mount fdisk 0.990
diff -uNr webmin-0.990.orig/man/config-pld-linux webmin-0.990/man/config-pld-linux
--- webmin-0.990.orig/man/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/man/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,4 @@
+search_cmd=man -k PAGE
+man_dir=/usr/share/man
+man_cmd_sect=man SECTION PAGE
+man_cmd=man PAGE
diff -uNr webmin-0.990.orig/mon/module.info webmin-0.990/mon/module.info
--- webmin-0.990.orig/mon/module.info	Mon Jul  1 07:04:42 2002
+++ webmin-0.990/mon/module.info	Mon Jul  1 11:23:21 2002
@@ -1,6 +1,6 @@
 category=system
 depends=init 0.990
-os_support=msc-linux redhat-linux open-linux slackware-linux debian-linux suse-linux corel-linux turbo-linux cobalt-linux mandrake-linux debian-linux generic-linux gentoo-linux
+os_support=msc-linux redhat-linux open-linux slackware-linux debian-linux suse-linux corel-linux turbo-linux cobalt-linux mandrake-linux debian-linux generic-linux gentoo-linux pld-linux
 desc=MON Service Monitor
 version=0.990
 desc_ca=Monitor de Serveis MON
diff -uNr webmin-0.990.orig/mount/config-pld-linux webmin-0.990/mount/config-pld-linux
--- webmin-0.990.orig/mount/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/mount/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,6 @@
+auto_file=/etc/amd.conf
+autofs_file=/etc/autofs/auto.master
+long_fstypes=1
+fstab_file=/etc/fstab
+smbclient_path=smbclient
+nmblookup_path=nmblookup
diff -uNr webmin-0.990.orig/mount/pld-linux-lib.pl webmin-0.990/mount/pld-linux-lib.pl
--- webmin-0.990.orig/mount/pld-linux-lib.pl	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/mount/pld-linux-lib.pl	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,1672 @@
+# linux-lib.pl
+# Mount table functions for linux
+
+if (&has_command("amd")) {
+	local $amd = &read_amd_conf();
+	$amd_support = $amd =~ /\[\s*global\s*\]/i ? 2 : 1;
+	}
+$autofs_support = &has_command("automount");
+if (&has_command("mount.smb")) {
+	$smbfs_support = `mount.smb -v` =~ /username=/i ? 4 : 3;
+	}
+elsif (&has_command("smbmount")) {
+	$smbfs_support = `smbmount -v` =~ /Version\s+2/i ? 2 : 1;
+	}
+$swaps_support = -r "/proc/swaps";
+
+# Return information about a filesystem, in the form:
+#  directory, device, type, options, fsck_order, mount_at_boot
+# If a field is unused or ignored, a - appears instead of the value.
+# Swap-filesystems (devices or files mounted for VM) have a type of 'swap',
+# and 'swap' in the directory field
+sub list_mounts
+{
+local(@rv, @p, @o, $_, $i, $j); $i = 0;
+
+# Get /etc/fstab mounts
+open(FSTAB, $config{fstab_file});
+while(<FSTAB>) {
+	local(@o, $at_boot);
+	chop; s/#.*$//g;
+	if (!/\S/ || /\signore\s/) { next; }
+	@p = split(/\s+/, $_);
+	if ($p[2] eq "proc") { $p[0] = "proc"; }
+	elsif ($p[2] eq "auto") { $p[2] = "*"; }
+	elsif ($p[2] eq "swap") { $p[1] = "swap"; }
+	$rv[$i] = [ $p[1], $p[0], $p[2] ];
+	$rv[$i]->[5] = "yes";
+	@o = split(/,/ , $p[3] eq "defaults" ? "" : $p[3]);
+	if (($j = &indexof("noauto", @o)) >= 0) {
+		# filesytem is not mounted at boot
+		splice(@o, $j, 1);
+		$rv[$i]->[5] = "no";
+		}
+	$rv[$i]->[3] = (@o ? join(',' , @o) : "-");
+	$rv[$i]->[4] = (@p >= 5 ? $p[5] : 0);
+	$i++;
+	}
+close(FSTAB);
+
+if ($amd_support == 1) {
+	# Get old automounter configuration, as used by redhat
+	local $amd = &read_amd_conf();
+	if ($amd =~ /MOUNTPTS='(.*)'/) {
+		@p = split(/\s+/, $1);
+		for($j=0; $j<@p; $j+=2) {
+			$rv[$i++] = [ $p[$j], $p[$j+1], "auto",
+				      "-", 0, "yes" ];
+			}
+		}
+	}
+elsif ($amd_support == 2) {
+	# Guess what? There's now a *new* amd config file format, introduced
+	# in redhat 6.1 and caldera 2.3
+	local @amd = &parse_amd_conf();
+	local @sp = split(/:/, $amd[0]->{'opts'}->{'search_path'});
+	local ($am, $sp);
+	foreach $am (@amd) {
+		local $mn = $am->{'opts'}->{'map_name'};
+		if ($mn !~ /^\//) {
+			foreach $sp (@sp) {
+				if (-r "$sp/$mn") {
+					$mn = "$sp/$mn";
+					last;
+					}
+				}
+			}
+		$rv[$i++] = [ $am->{'dir'}, $mn,
+			      "auto", $am->{'opts'}, 0, "yes" ]
+			if ($am->{'dir'} ne 'global');
+		}
+	}
+
+# Get kernel automounter configuration
+if ($autofs_support) {
+	open(AUTO, $config{'autofs_file'});
+	while(<AUTO>) {
+		chop;
+		s/#.*$//g;
+		if (/^\s*(\S+)\s+(\S+)\s*(.*)$/) {
+			$rv[$i++] = [ $1, $2, "autofs",
+				      ($3 ? &autofs_options($3) : "-"),
+				      0, "yes" ];
+			}
+		}
+	close(AUTO);
+	}
+
+return @rv;
+}
+
+
+# create_mount(directory, device, type, options, fsck_order, mount_at_boot)
+# Add a new entry to the fstab file, old or new automounter file
+sub create_mount
+{
+local(@mlist, @amd, $_); local($opts);
+
+if ($_[2] eq "auto") {
+	if ($amd_support == 1) {
+		# Adding an old automounter mount
+		local $amd = &read_amd_conf();
+		local $m = "$_[0] $_[1]";
+		if ($amd =~ /MOUNTPTS=''/) {
+			$amd =~ s/MOUNTPTS=''/MOUNTPTS='$m'/;
+			}
+		else {
+			$amd =~ s/MOUNTPTS='(.*)'/MOUNTPTS='$1 $m'/;
+			}
+		&write_amd_conf($amd);
+		}
+	elsif ($amd_support == 2) {
+		# Adding a new automounter mount
+		open(AMD, ">>$config{'auto_file'}");
+		print AMD "\n";
+		print AMD "[ $_[0] ]\n";
+		print AMD "map_name = $_[1]\n";
+		close(AMD);
+		}
+	}
+elsif ($_[2] eq "autofs") {
+	# Adding a new automounter mount
+	open(AUTO, ">> $config{'autofs_file'}");
+	print AUTO "$_[0]  $_[1]";
+	if ($_[3]) { print AUTO "  ",&autofs_args($_[3]); }
+	print AUTO "\n";
+	close(AUTO);
+	}
+else {
+	# Adding a normal mount to the fstab file
+	open(FSTAB, ">> $config{fstab_file}");
+	print FSTAB "$_[1]  $_[0]  $_[2]";
+	$opts = $_[3] eq "-" ? "" : $_[3];
+	if ($_[5] eq "no") {
+		$opts = join(',' , (split(/,/ , $opts) , "noauto"));
+		}
+	if ($opts eq "") { print FSTAB "  defaults"; }
+	else { print FSTAB "  $opts"; }
+	print FSTAB "  0  ";
+	print FSTAB $_[4] eq "-" ? "0\n" : "$_[4]\n";
+	close(FSTAB);
+	}
+}
+
+
+# change_mount(num, directory, device, type, options, fsck_order, mount_at_boot)
+# Change an existing permanent mount
+sub change_mount
+{
+local($i, @fstab, $line, $opts, $j, @amd);
+$i = 0;
+
+# Update fstab file
+open(FSTAB, $config{fstab_file});
+@fstab = <FSTAB>;
+close(FSTAB);
+open(FSTAB, "> $config{fstab_file}");
+foreach (@fstab) {
+	chop; ($line = $_) =~ s/#.*$//g;
+	if ($line =~ /\S/ && $line !~ /\signore\s/ && $i++ == $_[0]) {
+		# Found the line to replace
+		print FSTAB "$_[2]  $_[1]  $_[3]";
+		$opts = $_[4] eq "-" ? "" : $_[4];
+		if ($_[6] eq "no") {
+			$opts = join(',' , (split(/,/ , $opts) , "noauto"));
+			}
+		if ($opts eq "") { print FSTAB "  defaults"; }
+		else { print FSTAB "  $opts"; }
+		print FSTAB "  0  ";
+		print FSTAB $_[5] eq "-" ? "0\n" : "$_[5]\n";
+		}
+	else { print FSTAB $_,"\n"; }
+	}
+close(FSTAB);
+
+if ($amd_support == 1) {
+	# Update older amd configuration
+	local $amd = &read_amd_conf();
+	if ($amd =~ /MOUNTPTS='(.*)'/) {
+		# found mount points line..
+		local @mpts = split(/\s+/, $1);
+		for($j=0; $j<@mpts; $j+=2) {
+			if ($i++ == $_[0]) {
+				$mpts[$j] = $_[1];
+				$mpts[$j+1] = $_[2];
+				}
+			}
+		local $mpts = join(" ", @mpts);
+		$amd =~ s/MOUNTPTS='(.*)'/MOUNTPTS='$mpts'/;
+		}
+	&write_amd_conf($amd);
+	}
+elsif ($amd_support == 2) {
+	# Update new amd configuration
+	local @amd = &parse_amd_conf();
+	local $lref = &read_file_lines($config{'auto_file'});
+	foreach $am (@amd) {
+		next if ($am->{'dir'} eq 'global');
+		if ($i++ == $_[0]) {
+			local @nl = ( "[ $_[1] ]" );
+			local %opts = %{$am->{'opts'}};
+			$opts->{'map_name'} = $_[2];
+			foreach $o (keys %opts) {
+				push(@nl, "$o = $opts{$o}");
+				}
+			splice(@$lref, $am->{'line'},
+			       $am->{'eline'} - $am->{'line'} + 1, @nl);
+			}
+		}
+	&flush_file_lines();
+	}
+
+# Update autofs configuration
+if ($autofs_support) {
+	open(AUTO, $config{'autofs_file'});
+	@auto = <AUTO>;
+	close(AUTO);
+	open(AUTO, "> $config{'autofs_file'}");
+	foreach (@auto) {
+		chop; ($line = $_) =~ s/#.*$//g;
+		if ($line =~ /\S/ && $i++ == $_[0]) {
+			print AUTO "$_[1]  $_[2]";
+			if ($_[4]) { print AUTO "  ",&autofs_args($_[4]); }
+			print AUTO "\n";
+			}
+		else { print AUTO $_,"\n"; }
+		}
+	close(AUTO);
+	}
+}
+
+
+# delete_mount(index)
+# Delete an existing permanent mount
+sub delete_mount
+{
+local($i, @fstab, $line, $opts, $j, @amd);
+$i = 0;
+
+# Update fstab file
+open(FSTAB, $config{fstab_file});
+@fstab = <FSTAB>;
+close(FSTAB);
+open(FSTAB, "> $config{fstab_file}");
+foreach (@fstab) {
+	chop; ($line = $_) =~ s/#.*$//g;
+	if ($line !~ /\S/ || $line =~ /\signore\s/ || $i++ != $_[0]) {
+		# Don't delete this line
+		print FSTAB $_,"\n";
+		}
+	}
+close(FSTAB);
+
+if ($amd_support == 1) {
+	# Update older amd configuration
+	local $amd = &read_amd_conf();
+	if ($amd =~ /MOUNTPTS='(.*)'/) {
+		# found mount points line..
+		local @mpts = split(/\s+/, $1);
+		for($j=0; $j<@mpts; $j+=2) {
+			if ($i++ == $_[0]) {
+				splice(@mpts, $j, 2);
+				}
+			}
+		local $mpts = join(" ", @mpts);
+		$amd =~ s/MOUNTPTS='(.*)'/MOUNTPTS='$mpts'/;
+		}
+	&write_amd_conf($amd);
+	}
+elsif ($amd_support == 2) {
+	# Update new amd configuration
+	local @amd = &parse_amd_conf();
+	local $lref = &read_file_lines($config{'auto_file'});
+	foreach $am (@amd) {
+		next if ($am->{'dir'} eq 'global');
+		if ($i++ == $_[0]) {
+			splice(@$lref, $am->{'line'},
+			       $am->{'eline'} - $am->{'line'} + 1);
+			}
+		}
+	&flush_file_lines();
+	}
+
+
+
+# Update AMD file
+if ($amd_support) {
+	open(AMD, $config{auto_file});
+	@amd = <AMD>;
+	close(AMD);
+	open(AMD, "> $config{auto_file}");
+	foreach (@amd) {
+		if (/MOUNTPTS='(.*)'/) {
+			# found mount points line..
+			@mpts = split(/\s+/, $1);
+			for($j=0; $j<@mpts; $j+=2) {
+				if ($i++ != $_[0]) {
+					push(@nmpts, $mpts[$j]);
+					push(@nmpts, $mpts[$j+1]);
+					}
+				}
+			print AMD "MOUNTPTS='".join(' ', @nmpts)."'\n";
+			}
+		else { print AMD $_; }
+		}
+	close(AMD);
+	}
+
+# Update autofs file
+if ($autofs_support) {
+	open(AUTO, $config{'autofs_file'});
+	@auto = <AUTO>;
+	close(AUTO);
+	open(AUTO, "> $config{'autofs_file'}");
+	foreach (@auto) {
+		chop; ($line = $_) =~ s/#.*$//g;
+		if ($line !~ /\S/ || $i++ != $_[0]) {
+			# keep this line
+			print AUTO $_,"\n";
+			}
+		}
+	close(AUTO);
+	}
+}
+
+
+# list_mounted()
+# Return a list of all the currently mounted filesystems and swap files.
+# The list is in the form:
+#  directory device type options
+sub list_mounted
+{
+local(@rv, @p, @o, $mo, $_, %smbopts);
+
+&read_smbopts();
+open(MTAB, "/etc/mtab");
+while(<MTAB>) {
+	chop;
+	s/#.*$//g; if (!/\S/) { next; }
+	@p = split(/\s+/, $_);
+	if ($p[2] eq "auto" || $p[0] =~ /^\S+:\(pid\d+\)$/) {
+		# Automounter map.. turn the map= option into the device
+		@o = split(/,/ , $p[3]);
+		($mo) = grep {/^map=/} (@o);
+		$mo =~ /^map=(.*)$/; $p[0] = $1;
+		$p[3] = join(',' , grep {!/^map=/} (@o));
+		$p[2] = "auto";
+		}
+	elsif ($p[2] eq "autofs") {
+		# Kernel automounter map.. use the pid to find the map
+		$p[0] =~ /automount\(pid(\d+)\)/ || next;
+		$out = `ps hwwww $1`;
+		$out =~ /automount\s+(.*)\s*(\S+)\s+(file|program|yp)(,\S+)?\s+(\S+)/ || next;
+		$p[0] = $5;
+		$p[3] = $1 ? &autofs_options($1) : "-";
+		}
+	elsif ($p[2] eq "smbfs") {
+		# Change from //FOO/BAR to \\foo\bar
+		$p[0] =~ s/\//\\/g;
+		$p[0] = lc($p[0]);
+		$p[3] = $smbopts{$p[1]};
+		}
+	elsif ($p[2] eq "proc") {
+		# The source for proc mounts is always proc
+		$p[0] = "proc";
+		}
+	push(@rv, [ $p[1], $p[0], $p[2], $p[3] ]);
+	}
+close(MTAB);
+open(SWAPS, "/proc/swaps");
+while(<SWAPS>) {
+	chop;
+	if (/^(\/\S+)\s+/) {
+		push(@rv, [ "swap", $1, "swap", "-" ]);
+		}
+	}
+close(SWAPS);
+return @rv;
+}
+
+
+# mount_dir(directory, device, type, options)
+# Mount a new directory from some device, with some options. Returns 0 if ok,
+# or an error string if failed
+sub mount_dir
+{
+local($out, $opts, $shar, %options, %smbopts);
+if ($_[2] eq "swap") {
+	# Use swapon to add the swap space..
+	$out = `swapon $_[1] 2>&1`;
+	if ($out =~ /Invalid argument/) {
+		# looks like this swap partition isn't ready yet.. set it up
+		$out = `mkswap $_[1] 2>&1`;
+		if ($?) { return "mkswap failed : <pre>$out</pre>"; }
+		$out = `swapon $_[1] 2>&1`;
+		}
+	if ($?) { return "<pre>$out</pre>"; }
+	}
+elsif ($_[2] eq "auto") {
+	# Old automounter filesystem
+	$out = `amd $_[0] $_[1] >/dev/null 2>/dev/null`;
+	if ($?) { return $text{'linux_eamd'}; }
+	}
+elsif ($_[2] eq "autofs") {
+	# New automounter filesystem
+	$opts = &autofs_args($_[3]);
+	$type = $_[1] !~ /^\// ? "yp" :
+		(-x $_[1]) ? "program" : "file";
+	$out = `automount $opts $_[0] $type $_[1] 2>&1`;
+	if ($?) { return &text('linux_eauto', "<pre>$out</pre>"); }
+	}
+elsif ($_[2] eq "smbfs") {
+	local $shar = $_[1];
+	$shar =~ s/\\/\//g;
+	if ($smbfs_support >= 3) {
+		# SMB filesystem mounted with mount command
+		$opts = $_[3] eq "-" ? "" : "-o \"$_[3]\"";
+		$out = `mount -t $_[2] $opts $shar $_[0] 2>&1`;
+		if ($? || $out =~ /failed/i) {
+			system("umount $_[0] >/dev/null 2>&1");
+			return "<pre>$out</pre>";
+			}
+		}
+	elsif ($smbfs_support == 2) {
+		# SMB filesystem mounted with version 2.x smbmount
+		&parse_options("smbfs", $_[3]);
+		$opts =
+		    ($options{'user'} ? "-U $options{'user'} " : "").
+		    ($options{'passwd'} ? "" : "-N ").
+		    ($options{'workgroup'} ? "-W $options{'workgroup'} " : "").
+		    ($options{'clientname'} ? "-n $options{'clientname'} " : "").
+		    ($options{'machinename'} ? "-I $options{'machinename'} " : "");
+		&foreign_require("proc", "proc-lib.pl");
+		local ($fh, $fpid) = &foreign_call(
+			"proc", "pty_process_exec", "sh", "-c",
+			"smbmount $shar $_[0] -d 0 $opts");
+		if ($options{'passwd'}) {
+			local $w = &wait_for($fh, "word:");
+			if ($w < 0) {
+				system("umount $_[0] >/dev/null 2>&1");
+				return $text{'linux_esmbconn'};
+				}
+			local $p = "$options{'passwd'}\n";
+			syswrite($fh, $p, length($p));
+			}
+		local $got;
+		while(<$fh>) {
+			$got .= $_;
+			}
+		if ($got =~ /failed/) {
+			system("umount $_[0] >/dev/null 2>&1");
+			return "<pre>$got</pre>\n";
+			}
+		close($fh);
+		}
+	elsif ($smbfs_support == 1) {
+		# SMB filesystem mounted with older smbmount
+		&parse_options("smbfs", $_[3]);
+		$shortname = &get_system_hostname();
+		if ($shortname =~ /^([^\.]+)\.(.+)$/) { $shortname = $1; }
+		$opts =
+		   ($options{servername} ? "-s $options{servername} " : "").
+		   ($options{clientname} ? "-c $options{clientname} "
+					 : "-c $shortname ").
+		   ($options{machinename} ? "-I $options{machinename} " : "").
+		   ($options{user} ? "-U $options{user} " : "").
+		   ($options{passwd} ? "-P $options{passwd} " : "-n ").
+		   ($options{uid} ? "-u $options{uid} " : "").
+		   ($options{gid} ? "-g $options{gid} " : "").
+		   ($options{fmode} ? "-f $options{fmode} " : "").
+		   ($options{dmode} ? "-d $options{dmode} " : "");
+		$out = `smbmount $shar $_[0] $opts 2>&1`;
+		if ($out) {
+			system("umount $_[0] >/dev/null 2>&1");
+			return "<pre>$out</pre>";
+			}
+		}
+	&read_smbopts();
+	$smbopts{$_[0]} = $_[3] eq "-" ? "dummy=1" : $_[3];
+	&write_smbopts();
+	}
+else {
+	# some filesystem supported by mount
+	$opts = $_[3] eq "-" ? "" : "-o \"$_[3]\"";
+	$out = `mount -t $_[2] $opts $_[1] $_[0] 2>&1`;
+	if ($?) { return "<pre>$out</pre>"; }
+	}
+return 0;
+}
+
+
+# unmount_dir(directory, device, type)
+# Unmount a directory that is currently mounted. Returns 0 if ok,
+# or an error string if failed
+sub unmount_dir
+{
+local($out, %smbopts, $dir);
+if ($_[2] eq "swap") {
+	# Use swapoff to remove the swap space..
+	$out = `swapoff $_[1]`;
+	if ($?) { return "<pre>$out</pre>"; }
+	}
+elsif ($_[2] eq "auto") {
+	# Kill the amd process
+	$dir = $_[0];
+	if (`cat /etc/mtab` =~ /:\(pid([0-9]+)\)\s+$dir\s+(auto|nfs)\s+/) {
+		kill('TERM', $1) || return $text{'linux_ekillamd'};
+		}
+	sleep(2);
+	}
+elsif ($_[2] eq "autofs") {
+	# Kill the automount process
+	$dir = $_[0];
+	`cat /etc/mtab` =~ /automount\(pid([0-9]+)\)\s+$dir\s+autofs\s+/;
+	kill('TERM', $1) || return $text{'linux_ekillauto'};
+	sleep(2);
+	}
+else {
+	$out = `umount $_[0] 2>&1`;
+	if ($?) { return "<pre>$out</pre>"; }
+	if ($_[2] eq "smbfs") {
+		# remove options from list
+		&read_smbopts();
+		delete($smbopts{$_[0]});
+		&write_smbopts();
+		}
+	}
+return 0;
+}
+
+
+# mount_modes(type)
+# Given a filesystem type, returns 4 numbers that determine how the file
+# system can be mounted, and whether it can be fsck'd
+#  0 - cannot be permanently recorded
+#	(smbfs under linux before 2.2)
+#  1 - can be permanently recorded, and is always mounted at boot
+#	(swap under linux)
+#  2 - can be permanently recorded, and may or may not be mounted at boot
+#	(most normal filesystems)
+# The second is:
+#  0 - mount is always permanent => mounted when saved
+#	(swap under linux before 2.2)
+#  1 - doesn't have to be permanent
+#	(normal fs types)
+# The third is:
+#  0 - cannot be fsck'd at boot time
+#  1 - can be be fsck'd at boot
+# The fourth is:
+#  0 - can be unmounted
+#  1 - cannot be unmounted
+sub mount_modes
+{
+if ($_[0] eq "swap")
+	{ return (1, $swaps_support ? 1 : 0, 0, 0); }
+elsif ($_[0] eq "auto" || $_[0] eq "autofs")
+	{ return (1, 1, 0, 0); }
+elsif ($_[0] eq "smbfs")
+	{ return ($smbfs_support >= 3 ? 2 : 0, 1, 0, 0); }
+elsif ($_[0] eq "ext2" || $_[0] eq "minix" || $_[0] eq "xiafs")
+	{ return (2, 1, 1, 0); }
+else
+	{ return (2, 1, 0, 0); }
+}
+
+
+# disk_space(type, directory)
+# Returns the amount of total and free space for some filesystem, or an
+# empty array if not appropriate.
+sub disk_space
+{
+if (&get_mounted($_[1], "*") < 0) { return (); }
+if ($_[0] eq "proc" || $_[0] eq "swap" ||
+    $_[0] eq "auto" || $_[0] eq "autofs") { return (); }
+`df -k $_[1]` =~ /Mounted on\n\S+\s+(\S+)\s+\S+\s+(\S+)/;
+return ($1, $2);
+}
+
+
+# list_fstypes()
+# Returns an array of all the supported filesystem types. If a filesystem is
+# found that is not one of the supported types, generate_location() and
+# generate_options() will not be called for it.
+sub list_fstypes
+{
+local @sup = ("ext2", "minix", "msdos", "nfs", "iso9660", "ext", "xiafs",
+	      "hpfs", "fat", "vfat", "umsdos", "sysv", "reiserfs");
+push(@sup, "smbfs") if ($smbfs_support);
+push(@sup, "auto") if ($amd_support);
+push(@sup, "autofs") if ($autofs_support);
+push(@sup, "swap");
+return @sup;
+}
+
+
+# fstype_name(type)
+# Given a short filesystem type, return a human-readable name for it
+sub fstype_name
+{
+local(%fsmap);
+%fsmap = ("ext2","Linux Native Filesystem",
+	  "minix","Minix Filesystem",
+	  "msdos","MS-DOS Filesystem",
+	  "nfs","Network Filesystem",
+	  "smbfs","Windows Networking Filesystem",
+	  "iso9660","ISO9660 CD-ROM",
+	  "ext","Old EXT Linux Filesystem",
+	  "xiafs","Old XIAFS Linux Filesystem",
+	  "hpfs","OS/2 Filesystem",
+	  "fat","MS-DOS Filesystem",
+	  "vfat","Windows 95 Filesystem",
+	  "umsdos","Linux on top of MS-DOS Filesystem",
+	  "sysv","System V Filesystem",
+	  "swap","Virtual Memory",
+	  "proc","Kernel Filesystem",
+	  "devpts","PTS Filesystem",
+	  "auto",($autofs_support ? "Old " : "")."Automounter Filesystem",
+	  "reiserfs","Reiser Filesystem",
+	  "autofs","New Automounter Filesystem");
+return $config{long_fstypes} && $fsmap{$_[0]} ? $fsmap{$_[0]} : uc($_[0]);
+}
+
+
+# multiple_mount(type)
+# Returns 1 if filesystems of this type can be mounted multiple times, 0 if not
+sub multiple_mount
+{
+return ($_[0] eq "nfs" || $_[0] eq "auto" || $_[0] eq "autofs");
+}
+
+
+# generate_location(type, location)
+# Output HTML for editing the mount location of some filesystem.
+sub generate_location
+{
+if ($_[0] eq "nfs") {
+	# NFS mount from some host and directory
+	$_[1] =~ /^([^:]+):(.*)$/;
+	print "<tr> <td><b>$text{'linux_nfshost'}</b></td>\n";
+	print "<td><input name=nfs_host size=20 value=\"$1\">\n";
+	&nfs_server_chooser_button("nfs_host");
+	print "&nbsp;<b>$text{'linux_nfsdir'}</b>\n";
+	print "<input name=nfs_dir size=20 value=\"$2\">\n";
+	&nfs_export_chooser_button("nfs_host", "nfs_dir");
+	print "</td> </tr>\n";
+	}
+elsif ($_[0] eq "auto") {
+	# Using some automounter map
+	print "<tr> <td><b>$text{'linux_map'}</b></td>\n";
+	print "<td><input name=auto_map size=20 value=\"$_[1]\">\n";
+	print &file_chooser_button("auto_map", 0);
+	print "</td> <td colspan=2></td> </tr>\n";
+	}
+elsif ($_[0] eq "autofs") {
+	# Using some kernel automounter map
+	print "<tr> <td><b>$text{'linux_map'}</b></td>\n";
+	print "<td><input name=autofs_map size=20 value=\"$_[1]\">\n";
+	print &file_chooser_button("autofs_map", 0);
+	print "</td> <td colspan=2></td> </tr>\n";
+	}
+elsif ($_[0] eq "swap") {
+	# Swap file or device
+	&foreign_require("fdisk", "fdisk-lib.pl");
+	printf "<tr> <td valign=top><b>$text{'linux_swapfile'}</b></td>\n";
+	print "<td colspan=3>\n";
+	local $found;
+	local $sel = &foreign_call("fdisk", "partition_select", "lnx_disk",
+				   $_[1], 3, \$found);
+	printf "<input type=radio name=lnx_dev value=0 %s> %s %s<br>\n",
+		$found ? "checked" : "", $text{'linux_disk'}, $sel;
+	printf "<input type=radio name=lnx_dev value=1 %s> %s\n",
+		$found ? "" : "checked", $text{'linux_swapfile'};
+	printf "<input name=lnx_other size=35 value='%s'><br>\n",
+		$found ? "" : $_[1];
+	print "</td> </tr>\n";
+	}
+elsif ($_[0] eq "smbfs") {
+	# Windows filesystem
+	$_[1] =~ /^\\\\(.*)\\(.*)$/;
+	print "<tr> <td><b>$text{'linux_smbserver'}</b></td>\n";
+	print "<td><input name=smbfs_server value=\"$1\" size=20>\n";
+	&smb_server_chooser_button("smbfs_server");
+	print "</td>\n";
+	print "<td><b>$text{'linux_smbshare'}</b></td>\n";
+	print "<td><input name=smbfs_share value=\"$2\" size=20>\n";
+	&smb_share_chooser_button("smbfs_server", "smbfs_share");
+	print "</td> </tr>\n";
+	}
+else {
+	# This is some linux disk-based filesystem
+	&foreign_require("fdisk", "fdisk-lib.pl");
+	printf "<tr> <td valign=top><b>%s</b></td>\n", &fstype_name($_[0]);
+	print "<td colspan=3>\n";
+	local ($found, $rfound, $rsel, $c);
+	local $sel = &foreign_call("fdisk", "partition_select", "lnx_disk",
+				   $_[1], 0, \$found);
+	printf "<input type=radio name=lnx_dev value=0 %s> %s %s<br>\n",
+		$found ? "checked" : "", $text{'linux_disk'}, $sel;
+
+	&foreign_require("raid", "raid-lib.pl");
+	local $conf = &foreign_call("raid", "get_raidtab");
+	foreach $c (@$conf) {
+		if ($c->{'active'}) {
+			$rsel .= sprintf "<option value=%s %s>%s\n",
+				$c->{'value'},
+				$_[1] eq $c->{'value'} ? 'selected' : '',
+				&text('linux_rdev', substr($c->{'value'}, -1));
+			$rfound++ if ($_[1] eq $c->{'value'});
+			}
+		}
+	if ($rsel) {
+		printf "<input type=radio name=lnx_dev value=2 %s> %s\n",
+			$rfound ? "checked" : " ", $text{'linux_raid'};
+		print "<select name=lnx_raid>\n",$rsel,"</select><br>\n";
+		}
+
+	printf "<input type=radio name=lnx_dev value=1 %s> %s\n",
+		$found || $rfound ? "" : "checked", $text{'linux_other'};
+	printf "<input name=lnx_other size=35 value='%s'><br>\n",
+		$found || $rfound ? "" : $_[1];
+	print "</td> </tr>\n";
+	}
+}
+
+
+# generate_options(type, newmount)
+# Output HTML for editing mount options for a particular filesystem 
+# under this OS
+sub generate_options
+{
+if ($_[0] ne "swap" && $_[0] ne "auto" &&
+    $_[0] ne "autofs" && $_[0] ne "smbfs") {
+	# Lots of options are common to all linux filesystems
+	print "<tr> <td><b>$text{'linux_ro'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=lnx_ro value=1 %s> $text{'yes'}\n",
+		defined($options{"ro"}) ? "checked" : "";
+	printf "<input type=radio name=lnx_ro value=0 %s> $text{'no'}</td>\n",
+		defined($options{"ro"}) ? "" : "checked";
+
+	print "<td><b>$text{'linux_sync'}</b></td>\n";
+	printf"<td nowrap><input type=radio name=lnx_sync value=0 %s> $text{'yes'}\n",
+		defined($options{"sync"}) ? "" : "checked";
+	printf "<input type=radio name=lnx_sync value=1 %s> $text{'no'}</td> </tr>\n",
+		defined($options{"sync"}) ? "checked" : "";
+
+	print "<tr> <td><b>$text{'linux_nodev'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=lnx_nodev value=0 %s> $text{'yes'}\n",
+		defined($options{"nodev"}) ? "" : "checked";
+	printf "<input type=radio name=lnx_nodev value=1 %s> $text{'no'}</td>\n",
+		defined($options{"nodev"}) ? "checked" : "";
+
+	print "<td><b>$text{'linux_noexec'}</b></td>\n";
+	printf"<td nowrap><input type=radio name=lnx_noexec value=0 %s> $text{'yes'}\n",
+		defined($options{"noexec"}) ? "" : "checked";
+	printf "<input type=radio name=lnx_noexec value=1 %s> $text{'no'}</td> </tr>\n",
+		defined($options{"noexec"}) ? "checked" : "";
+
+	print "<tr> <td><b>$text{'linux_nosuid'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=lnx_nosuid value=1 %s> $text{'yes'}\n",
+		defined($options{"nosuid"}) ? "checked" : "";
+	printf "<input type=radio name=lnx_nosuid value=0 %s> $text{'no'}</td>\n",
+		defined($options{"nosuid"}) ? "" : "checked";
+
+	print "<td><b>$text{'linux_user'}</b></td>\n";
+	printf"<td nowrap><input type=radio name=lnx_user value=1 %s> $text{'yes'}\n",
+		defined($options{"user"}) ? "checked" : "";
+	printf "<input type=radio name=lnx_user value=0 %s> $text{'no'}</td> </tr>\n",
+		defined($options{"user"}) ? "" : "checked";
+	}
+	
+if ($_[0] eq "ext2") {
+	# Ext2 has lots more options..
+	print "<tr> <td><b>$text{'linux_check'}</b></td>\n";
+	print "<td><select name=ext2_check>\n";
+	printf "<option value=normal %s> $text{'linux_normal'}\n",
+		$options{"check"} eq "" || $options{"check"} eq "normal" ?
+			"selected" : "";
+	printf "<option value=strict %s> $text{'linux_strict'}\n",
+		$options{"check"} eq "strict" ? "selected" : "";
+	printf "<option value=none %s> $text{'linux_none'}\n",
+		$options{"check"} eq "none" || defined($options{"nocheck"}) ?
+			"selected" : "";
+	print "</select></td>\n";
+
+	print "<td><b>$text{'linux_errors'}</b></td>\n";
+	print "<td><select name=ext2_errors>\n";
+	printf "<option value=default %s> $text{'default'}\n",
+		!defined($options{"errors"}) ? "selected" : "";
+	printf "<option value=continue %s> $text{'linux_continue'}\n",
+		$options{"error"} eq "continue" ? "selected" : "";
+	printf "<option value=remount-ro %s> $text{'linux_remount_ro'}\n",
+		$options{"error"} eq "remount-ro" ? "selected" : "";
+	printf "<option value=panic %s> $text{'linux_panic'}\n",
+		$options{"error"} eq "panic" ? "selected" : "";
+	print "</select></td> </tr>\n";
+
+	print "<tr> <td><b>$text{'linux_grpid'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=ext2_grpid value=0 %s> $text{'yes'}\n",
+		defined($options{"grpid"}) || defined($options{"bsdgroups"}) ?
+			"" : "checked";
+	printf "<input type=radio name=ext2_grpid value=1 %s> $text{'no'}</td>\n",
+		defined($options{"grpid"}) || defined($options{"bsdgroups"}) ?
+			"checked" : "";
+
+	print "<td><b>$text{'linux_quotas'}</b></td>\n";
+	local $usrquota = defined($options{"usrquota"});
+	local $grpquota = defined($options{"grpquota"});
+	print "<td nowrap><select name=ext2_quota>\n";
+	printf "<option value=0 %s> $text{'no'}\n",
+		$usrquota || $grpquota ? "" : "selected";
+	printf "<option value=1 %s> $text{'linux_usrquota'}\n",
+		$usrquota && !$grpquota ? "selected" : "";
+	printf "<option value=2 %s> $text{'linux_grpquota'}\n",
+		$grpquota && !$usrquota ? "selected" : "";
+	if (`uname -r` =~ /^2\.0\.(\d+)/ && $1 < 31) {
+		printf "<option value=3 %s> $text{'linux_usrgrpquota2'}\n",
+			$usrquota && $grpquota ? "selected" : "";
+		}
+	else {
+		printf "<option value=3 %s> $text{'linux_usrgrpquota'}\n",
+			$usrquota && $grpquota ? "selected" : "";
+		}
+	print "</select></td> </tr>\n";
+
+	print "<tr> <td><b>$text{'linux_resuid'}</b></td>\n";
+	printf "<td><input name=ext2_resuid size=8 value=\"%s\">\n",
+		defined($options{"resuid"}) ? getpwuid($options{"resuid"}) : "";
+	print &user_chooser_button("ext2_resuid", 0),"</td>\n";
+
+	print "<td><b>$text{'linux_resgid'}</b></td>\n";
+	printf "<td><input name=ext2_resgid size=8 value=\"%s\">\n",
+		defined($options{"resgid"}) ? getgrgid($options{"resgid"}) : "";
+	print &group_chooser_button("ext2_resgid", 0),"</td> </tr>\n";
+	}
+elsif ($_[0] eq "nfs") {
+	# Linux nfs has some more options...
+	print "<tr> <td><b>$text{'linux_bg'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=nfs_bg value=1 %s> $text{'yes'}\n",
+		defined($options{"bg"}) ? "checked" : "";
+	printf "<input type=radio name=nfs_bg value=0 %s> $text{'no'}</td>\n",
+		defined($options{"bg"}) ? "" : "checked";
+
+	print "<td><b>$text{'linux_soft'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=nfs_soft value=1 %s> $text{'yes'}\n",
+		defined($options{"soft"}) ? "checked" : "";
+	printf "<input type=radio name=nfs_soft value=0 %s> $text{'no'}</td> </tr>\n",
+		defined($options{"soft"}) ? "" : "checked";
+
+	print "<tr> <td><b>$text{'linux_timeo'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=nfs_timeo_def value=1 %s> $text{'default'}\n",
+		defined($options{"timeo"}) ? "" : "checked";
+	printf "<input type=radio name=nfs_timeo_def value=0 %s>\n",
+		defined($options{"timeo"}) ? "checked" : "";
+	printf "<input size=5 name=nfs_timeo value=$options{timeo}></td>\n";
+
+	print "<td><b>$text{'linux_retrans'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=nfs_retrans_def value=1 %s> $text{'default'}\n",
+		defined($options{"retrans"}) ? "" : "checked";
+	printf "<input type=radio name=nfs_retrans_def value=0 %s>\n",
+		defined($options{"retrans"}) ? "checked" : "";
+	print "<input size=5 name=nfs_retrans value=$options{retrans}></td> </tr>\n";
+
+	print "<tr> <td><b>$text{'linux_vers'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=nfs_vers_def value=1 %s> $text{'linux_high'}\n",
+		defined($options{"nfsvers"}) ? "" : "checked";
+	printf "<input type=radio name=nfs_vers_def value=0 %s>\n",
+		defined($options{"nfsvers"}) ? "checked" : "";
+	print "<input size=1 name=nfsvers value=$options{nfsvers}></td>\n";
+
+	print "<td><b>$text{'linux_port'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=nfs_port_def value=1 %s> $text{'default'}\n",
+		defined($options{"port"}) ? "" : "checked";
+	printf "<input type=radio name=nfs_port_def value=0 %s>\n",
+		defined($options{"port"}) ? "checked" : "";
+	print "<input size=5 name=nfs_port value=$options{port}></td> </tr>\n";
+
+	print "<tr> <td><b>$text{'linux_intr'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=nfs_intr value=1 %s> $text{'yes'}\n",
+		defined($options{"intr"}) ? "checked" : "";
+	printf "<input type=radio name=nfs_intr value=0 %s> $text{'no'}</td>\n",
+		defined($options{"intr"}) ? "" : "checked";
+
+	print "<td><b>$text{'linux_tcp'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=nfs_tcp value=1 %s> TCP\n",
+		defined($options{"tcp"}) ? "checked" : "";
+	printf "<input type=radio name=nfs_tcp value=0 %s> UDP</td> </tr>\n",
+		defined($options{"tcp"}) ? "" : "checked";
+	}
+elsif ($_[0] eq "fat" || $_[0] eq "vfat" || $_[0] eq "msdos" || $_[0] eq "umsdos"){
+	# All dos-based filesystems share some options
+	print "<tr> <td><b>$text{'linux_uid'}</b></td>\n";
+	printf "<td><input name=fat_uid size=8 value=\"%s\">\n",
+		defined($options{'uid'}) ? getpwuid($options{'uid'}) : "";
+	print &user_chooser_button("fat_uid", 0),"</td>\n";
+
+	print "<td><b>$text{'linux_gid'}</b></td>\n";
+	printf "<td><input name=fat_gid size=8 value=\"%s\">\n",
+		defined($options{'gid'}) ? getgrgid($options{'gid'}) : "";
+	print &group_chooser_button("fat_gid", 0),"</td> </tr>\n";
+
+	print "<tr> <td><b>$text{'linux_rules'}</b></td>\n";
+	print "<td><select name=fat_check>\n";
+	printf "<option value=\"\" %s> $text{'default'}\n",
+		defined($options{"check"}) ? "" : "selected";
+	printf "<option value=r %s> $text{'linux_relaxed'}\n",
+		$options{"check"} =~ /^r/ ? "selected" : "";
+	printf "<option value=n %s> $text{'linux_normal'}\n",
+		$options{"check"} =~ /^n/ ? "selected" : "";
+	printf "<option value=s %s> $text{'linux_strict'}\n",
+		$options{"check"} =~ /^s/ ? "selected" : "";
+	print "</select></td>\n";
+
+	print "<td><b>$text{'linux_conv'}</b></td>\n";
+	print "<td><select name=fat_conv>\n";
+	printf "<option value=\"\" %s> $text{'linux_none'}\n",
+		$options{"conv"} =~ /^b/ || !defined($options{"conv"}) ?
+		"selected" : "";
+	printf "<option value=t %s> $text{'linux_allfiles'}\n",
+		$options{"conv"} =~ /^t/ ? "selected" : "";
+	printf "<option value=a %s> $text{'linux_textfiles'}\n",
+		$options{"conv"} =~ /^a/ ? "selected" : "";
+	print "</select></td> </tr>\n";
+
+	print "<tr> <td><b>$text{'linux_umask'}</b></td>\n";
+	printf "<td><input type=radio name=fat_umask_def value=1 %s> $text{'default'}\n",
+		defined($options{"umask"}) ? "" : "checked";
+	printf "<input type=radio name=fat_umask_def value=0 %s>\n",
+		defined($options{"umask"}) ? "checked" : "";
+	print "<input size=5 name=fat_umask value=\"$options{umask}\"></td>\n";
+
+	print "<td><b>$text{'linux_quiet'}</b></td>\n";
+	printf "<td nowrap><input type=radio name=fat_quiet value=0 %s> $text{'yes'}\n",
+		defined($options{"quiet"}) ? "" : "checked";
+	printf "<input type=radio name=fat_quiet value=1 %s> $text{'no'}</td> </tr>\n",
+		defined($options{"quiet"}) ? "checked" : "";
+
+	if ($_[0] eq "vfat") {
+		# vfat has some extra options beyond fat
+		print "<tr> <td><b>$text{'linux_uni_xlate'}</b></td>\n";
+		printf "<td><input type=radio name=fat_uni_xlate value=1 %s> $text{'yes'}\n",
+			defined($options{"uni_xlate"}) ? "checked" : "";
+		printf "<input type=radio name=fat_uni_xlate value=0 %s> $text{'no'}</td>\n",
+			defined($options{"uni_xlate"}) ? "" : "checked";
+
+		print "<td><b>$text{'linux_posix'}</b></td>\n";
+		printf "<td nowrap><input type=radio name=fat_posix value=1 %s> $text{'yes'}\n",
+			defined($options{"posix"}) ? "checked" : "";
+		printf "<input type=radio name=fat_posix value=0 %s> $text{'no'}</td> </tr>\n",
+			defined($options{"posix"}) ? "" : "checked";
+		}
+	}
+elsif ($_[0] eq "hpfs") {
+	# OS/2 filesystems has some more options..
+	print "<tr> <td><b>$text{'linux_uid'}</b></td>\n";
+	printf "<td><input name=hpfs_uid size=8 value=\"%s\">\n",
+		defined($options{"uid"}) ? getpwuid($options{"uid"}) : "";
+	print &user_chooser_button("hpfs_uid", 0),"</td>\n";
+
+	print "<td><b>$text{'linux_gid'}</b></td>\n";
+	printf "<td><input name=hpfs_gid size=8 value=\"%s\">\n",
+		defined($options{"gid"}) ? getgrgid($options{"gid"}) : "";
+	print &group_chooser_button("hpfs_gid", 0),"</td> </tr>\n";
+
+	print "<tr> <td><b>$text{'linux_umask'}</b></td>\n";
+	printf"<td><input type=radio name=hpfs_umask_def value=1 %s> Default\n",
+		defined($options{"umask"}) ? "" : "checked";
+	printf "<input type=radio name=hpfs_umask_def value=0 %s>\n",
+		defined($options{"umask"}) ? "checked" : "";
+	print "<input size=5 name=hpfs_umask value=\"$options{umask}\"></td>\n";
+
+	print "<td><b>$text{'linux_conv2'}</b></td>\n";
+	print "<td><select name=hpfs_conv>\n";
+	printf "<option value=b %s> $text{'linux_none'}\n",
+		$options{"conv"} =~ /^b/ || !defined($options{"conv"}) ?
+		"selected" : "";
+	printf "<option value=t %s> $text{'linux_allfiles'}\n",
+		$options{"conv"} =~ /^t/ ? "selected" : "";
+	printf "<option value=a %s> $text{'linux_textfiles'}\n",
+		$options{"conv"} =~ /^a/ ? "selected" : "";
+	print "</select></td> </tr>\n";
+	}
+elsif ($_[0] eq "iso9660") {
+	# CD-ROM filesystems have some more options..
+	print "<tr> <td><b>$text{'linux_uid'}</b></td>\n";
+	printf "<td><input name=iso9660_uid size=8 value=\"%s\">\n",
+		defined($options{"uid"}) ? getpwuid($options{"uid"}) : "";
+	print &user_chooser_button("iso9660_uid", 0),"</td>\n";
+
+	print "<td><b>$text{'linux_gid'}</b></td>\n";
+	printf "<td><input name=iso9660_gid size=8 value=\"%s\">\n",
+		defined($options{"gid"}) ? getgrgid($options{"gid"}) : "";
+	print &group_chooser_button("iso9660_gid", 0),"</td>\n";
+
+	print "<tr> <td><b>$text{'linux_rock'}</b></td>\n";
+	printf "<td><input type=radio name=iso9660_norock value=1 %s> $text{'yes'}\n",
+		defined($options{"norock"}) ? "checked" : "";
+	printf "<input type=radio name=iso9660_norock value=0 %s> $text{'no'}</td>\n",
+		defined($options{"norock"}) ? "" : "checked";
+
+	print "<td><b>$text{'linux_mode'}</b></td>\n";
+	printf"<td><input size=10 name=iso9660_mode value=\"%s\"></td> </tr>\n",
+		defined($options{"mode"}) ? $options{"mode"} : "444";
+	}
+elsif ($_[0] eq "auto") {
+	# Don't know how to set options for auto filesystems yet..
+	print "<tr> <td><i>$text{'linux_noopts'}</i></td> </tr>\n";
+	}
+elsif ($_[0] eq "autofs") {
+	print "<tr> <td><b>$text{'linux_timeout'}</b></td> <td>\n";
+	printf"<input type=radio name=autofs_timeout_def value=1 %s> $text{'default'}\n",
+		defined($options{'timeout'}) ? "" : "checked";
+	printf "<input type=radio name=autofs_timeout_def value=0 %s>\n",
+		defined($options{'timeout'}) ? "checked" : "";
+	printf "<input name=autofs_timeout size=5 value=\"%s\"> $text{'linux_secs'}</td>\n",
+		$options{'timeout'};
+
+	print "<td><b>$text{'linux_pid_file'}</b>?</td>\n";
+	printf"<td><input type=radio name=autofs_pid-file_def value=1 %s> $text{'no'}\n",
+		defined($options{'pid-file'}) ? "" : "checked";
+	printf "<input type=radio name=autofs_pid-file_def value=0 %s> $text{'yes'}\n",
+		defined($options{'pid-file'}) ? "checked" : "";
+	printf "<input name=autofs_pid-file size=20 value=\"%s\">\n",
+		$options{'pid-file'};
+	print &file_chooser_button("autofs_pid-file", 1);
+	print "</td> </tr>\n";
+	}
+elsif ($_[0] eq "swap") {
+	# Swap has no options..
+	print "<tr> <td><i>$text{'linux_noopts'}</i></td> </tr>\n";
+	}
+elsif ($_[0] eq "smbfs") {
+	# SMB filesystems have a few options..
+	if (keys(%options) == 0 && !$_[1]) {
+		print "<tr> <td colspan=4><i>$text{'linux_smbwarn'}</i></td> </tr>\n";
+		}
+
+	print "<tr> <td><b>$text{'linux_username'}</b></td>\n";
+	printf "<td><input name=smbfs_user size=15 value=\"%s\"></td>\n",
+		$smbfs_support == 4 ? $options{'username'} : $options{'user'};
+
+	print "<td><b>$text{'linux_password'}</b></td>\n";
+	printf "<td><input type=password name=smbfs_passwd size=15 value=\"%s\"></td> </tr>\n",
+		$smbfs_support == 4 ? $options{'password'} : $options{'passwd'};
+
+	if ($smbfs_support != 2) {
+		print "<tr> <td><b>$text{'linux_uid'}</b></td>\n";
+		printf "<td><input name=smbfs_uid size=8 value=\"%s\">\n",
+			defined($options{"uid"}) ? getpwuid($options{"uid"}) : "";
+		print &user_chooser_button("smbfs_uid", 0),"</td>\n";
+
+		print "<td><b>$text{'linux_gid'}</b></td>\n";
+		printf "<td><input name=smbfs_gid size=8 value=\"%s\">\n",
+			defined($options{"gid"}) ? getgrgid($options{"gid"}) : "";
+		print &group_chooser_button("smbfs_gid", 0),"</td>\n";
+		}
+
+	if ($smbfs_support == 1) {
+		print "<tr> <td><b>$text{'linux_sname'}</b></td>\n";
+		printf "<td><input type=radio name=smbfs_sname_def value=1 %s> $text{'linux_auto'}\n",
+			defined($options{"servername"}) ? "" : "checked";
+		printf "<input type=radio name=smbfs_sname_def value=0 %s>\n",
+			defined($options{"servername"}) ? "checked" : "";
+		print "<input size=10 name=smbfs_sname value=\"$options{servername}\"></td>\n";
+		}
+	elsif ($smbfs_support == 2) {
+		print "<tr> <td><b>$text{'linux_wg'}</b></td>\n";
+		printf "<td><input type=radio name=smbfs_wg_def value=1 %s> $text{'linux_auto'}\n",
+			defined($options{"workgroup"}) ? "" : "checked";
+		printf "<input type=radio name=smbfs_wg_def value=0 %s>\n",
+			defined($options{"workgroup"}) ? "checked" : "";
+		print "<input size=10 name=smbfs_wg value=\"$options{'workgroup'}\"></td>\n";
+		}
+
+	if ($smbfs_support < 3) {
+		print "<td><b>$text{'linux_cname'}</b></td>\n";
+		printf "<td><input type=radio name=smbfs_cname_def value=1 %s> $text{'linux_auto'}\n",
+			defined($options{"clientname"}) ? "" : "checked";
+		printf "<input type=radio name=smbfs_cname_def value=0 %s>\n",
+			defined($options{"clientname"}) ? "checked" : "";
+		print "<input size=10 name=smbfs_cname value=\"$options{clientname}\"></td> </tr>\n";
+
+		print "<tr> <td><b>$text{'linux_mname'}</b></td>\n";
+		printf "<td colspan=3><input type=radio name=smbfs_mname_def value=1 %s> %s\n",
+			defined($options{"machinename"}) ? "" : "checked", $text{'linux_auto'};
+		printf "<input type=radio name=smbfs_mname_def value=0 %s>\n",
+			defined($options{"machinename"}) ? "checked" : "";
+		print "<input size=30 name=smbfs_mname value=\"$options{machinename}\"></td> </tr>\n";
+		}
+
+	if ($smbfs_support == 1) {
+		print "<tr> <td><b>$text{'linux_fmode'}</b></td>\n";
+		printf
+		    "<td><input name=smbfs_fmode size=5 value=\"%s\"></td>\n",
+		    defined($options{'fmode'}) ? $options{'fmode'} : "755";
+
+		print "<td><b>$text{'linux_dmode'}</b></td>\n";
+		printf
+		    "<td><input name=smbfs_dmode size=5 value=\"%s\"></td>\n",
+		    defined($options{'dmode'}) ? $options{'dmode'} : "755";
+		print "</tr>\n";
+		}
+	elsif ($smbfs_support >= 3) {
+		print "<tr> <td><b>$text{'linux_ro'}</b></td>\n";
+		printf "<td><input type=radio name=lnx_ro value=1 %s> $text{'yes'}\n",
+			defined($options{"ro"}) ? "checked" : "";
+		printf "<input type=radio name=lnx_ro value=0 %s> $text{'no'}</td>\n",
+			defined($options{"ro"}) ? "" : "checked";
+		print "</tr>\n";
+		}
+	}
+elsif ($_[0] eq "reiserfs") {
+	# Reiserfs is a new super-efficient filesystem
+	print "<tr> <td><b>$text{'linux_notail'}</b></td>\n";
+	printf "<td><input type=radio name=lnx_notail value=1 %s> $text{'yes'}\n",
+		defined($options{"notail"}) ? "checked" : "";
+	printf "<input type=radio name=lnx_notail value=0 %s> $text{'no'}</td> </tr>\n",
+		defined($options{"notail"}) ? "" : "checked";
+	}
+}
+
+
+# check_location(type)
+# Parse and check inputs from %in, calling &error() if something is wrong.
+# Returns the location string for storing in the fstab file
+sub check_location
+{
+if ($_[0] eq "nfs") {
+	local($out, $temp, $mout, $dirlist);
+
+	if (&has_command("showmount")) {
+		# Use ping and showmount to see if the host exists and is up
+		if ($in{nfs_host} !~ /^\S+$/) {
+			&error(&text('linux_ehost', $in{'nfs_host'}));
+			}
+		$out = `ping -c 1 '$in{nfs_host}' 2>&1`;
+		if ($out =~ /unknown host/) {
+			&error(&text('linux_ehost2', $in{'nfs_host'}));
+			}
+		elsif ($out =~ /100\% packet loss/) {
+			&error(&text('linux_edown', $in{'nfs_host'}));
+			}
+		$out = `showmount -e '$in{nfs_host}' 2>&1`;
+		if ($out =~ /Unable to receive/) {
+			&error(&text('linux_enfs', $in{'nfs_host'}));
+			}
+		elsif ($?) {
+			&error(&text('linux_elist', $out));
+			}
+
+		# Validate directory name
+		foreach (split(/\n/, $out)) {
+			if (/^(\/\S+)/) { $dirlist .= "$1\n"; }
+			}
+		if ($in{nfs_dir} !~ /^\/\S+$/) {
+			&error(&text('linux_enfsdir', $in{'nfs_dir'},
+				     $in{'nfs_host'}, "<pre>$dirlist</pre>"));
+			}
+		}
+
+	# Try a test mount to see if filesystem is available
+	$temp = &tempname();
+	mkdir($temp, 0755);
+	$mout = `mount $in{nfs_host}:$in{nfs_dir} $temp 2>&1`;
+	if ($mout =~ /No such file or directory/i) {
+		rmdir($temp);
+		&error(&text('linux_enfsdir', $in{'nfs_dir'},
+			     $in{'nfs_host'}, "<pre>$dirlist</pre>"));
+		}
+	elsif ($mout =~ /Permission denied/i) {
+		rmdir($temp);
+		&error(&text('linux_enfsperm', $in{'nfs_dir'}, $in{'nfs_host'}));
+		}
+	elsif ($?) {
+		rmdir($temp);
+		&error(&text('linux_enfsmount', "<tt>$mout</tt>"));
+		}
+	# It worked! unmount
+	`umount $temp`;
+	rmdir($temp);
+
+	return "$in{nfs_host}:$in{nfs_dir}";
+	}
+elsif ($_[0] eq "auto") {
+	# Check if the automounter map exists..
+	(-r $in{auto_map}) || &error(&text('linux_eautomap', $in{'auto_map'}));
+	return $in{auto_map};
+	}
+elsif ($_[0] eq "autofs") {
+	# Check if the map exists (if it is a file)
+	if ($in{'autofs_map'} =~ /^\// && !(-r $in{'autofs_map'})) {
+		&error(&text('linux_eautomap', $in{'autofs_map'}));
+		}
+	return $in{autofs_map};
+	}
+elsif ($_[0] eq "smbfs") {
+	# No checking done
+	return "\\\\".lc($in{'smbfs_server'})."\\".lc($in{'smbfs_share'});
+	}
+else {
+	# This is some kind of disk-based linux filesystem.. get the device name
+	if ($in{'lnx_dev'} == 0) {
+		$dv = $in{'lnx_disk'};
+		}
+	elsif ($in{'lnx_dev'} == 2) {
+		$dv = $in{'lnx_raid'};
+		}
+	else {
+		$dv = $in{'lnx_other'};
+		$dv || &error($text{'linux_edev'});
+		}
+
+	# If the device entered is a symlink, follow it
+	if ($dvlink = readlink($dv)) {
+		if ($dvlink =~ /^\//) { $dv = $dvlink; }
+		else {	$dv =~ /^(.*\/)[^\/]+$/;
+			$dv = $1.$dvlink;
+			}
+		}
+
+	# Check if the device actually exists and uses the right filesystem
+	if (!(-r $dv)) {
+		if ($_[0] eq "swap" && $dv !~ /\/dev/) {
+			&swap_form($dv);
+			}
+		else {
+			&error(&text('linux_edevfile', $dv));
+			}
+		}
+	return $dv;
+	}
+}
+
+# check_options(type, device, directory)
+# Read options for some filesystem from %in, and use them to update the
+# %options array. Options handled by the user interface will be set or
+# removed, while unknown options will be left untouched.
+sub check_options
+{
+local($k, @rv);
+
+# Parse the common options first..
+if ($_[0] ne "swap" && $_[0] ne "auto" &&
+    $_[0] ne "autofs" && $_[0] ne "smbfs") {
+	delete($options{"ro"}); delete($options{"rw"});
+	if ($in{lnx_ro}) { $options{"ro"} = ""; }
+
+	delete($options{"sync"}); delete($options{"async"});
+	if ($in{lnx_sync}) { $options{"sync"} = ""; }
+
+	delete($options{"dev"}); delete($options{"nodev"});
+	if ($in{lnx_nodev}) { $options{"nodev"} = ""; }
+
+	delete($options{"exec"}); delete($options{"noexec"});
+	if ($in{lnx_noexec}) { $options{"noexec"} = ""; }
+
+	delete($options{"suid"}); delete($options{"nosuid"});
+	if ($in{lnx_nosuid}) { $options{"nosuid"} = ""; }
+
+	delete($options{"user"}); delete($options{"nouser"});
+	if ($in{lnx_user}) { $options{"user"} = ""; }
+	}
+
+if ($_[0] eq "nfs") {
+	# NFS has a few specific options..
+	delete($options{"bg"}); delete($options{"fg"});
+	if ($in{nfs_bg}) { $options{"bg"} = ""; }
+
+	delete($options{"soft"}); delete($options{"hard"});
+	if ($in{nfs_soft}) { $options{"soft"} = ""; }
+
+	delete($options{"timeo"});
+	if (!$in{nfs_timeo_def}) { $options{"timeo"} = $in{nfs_timeo}; }
+
+	delete($options{"nfsvers"});
+	if (!$in{nfs_vers_def}) { $options{"nfsvers"} = $in{nfs_vers}; }
+
+	delete($options{"port"});
+	if (!$in{nfs_port_def}) { $options{"port"} = $in{nfs_port}; }
+
+	delete($options{"intr"}); delete($options{"nointr"});
+	if ($in{nfs_intr}) { $options{"intr"} = ""; }
+
+	delete($options{"tcp"}); delete($options{"udp"});
+	if ($in{nfs_tcp}) { $options{"tcp"} = ""; }
+	}
+elsif ($_[0] eq "ext2") {
+	# More options for ext2..
+	delete($options{"check"}); delete($options{"nocheck"});
+	if ($in{ext2_check} ne "normal") {
+		$options{"check"} = $in{ext2_check};
+		}
+
+	delete($options{"errors"});
+	if ($in{ext2_errors} ne "default") {
+		$options{"errors"} = $in{ext2_errors};
+		}
+
+	delete($options{"grpid"}); delete($options{"bsdgroups"});
+	delete($options{"sysvgroups"}); delete($options{"nogrpid"});
+	if ($in{ext2_grpid}) {
+		$options{"grpid"} = "";
+		}
+
+	delete($options{"resuid"}); delete($options{"resgid"});
+	if ($in{'ext2_resuid'})
+		{ $options{"resuid"} = getpwnam($in{'ext2_resuid'}); }
+	if ($in{'ext2_resgid'})
+		{ $options{"resgid"} = getgrnam($in{'ext2_resgid'}); }
+
+	delete($options{"quota"}); delete($options{"noquota"});
+	delete($options{"usrquota"}); delete($options{"grpquota"});
+	if ($in{'ext2_quota'} == 1) { $options{'usrquota'} = ""; }
+	elsif ($in{'ext2_quota'} == 2) { $options{'grpquota'} = ""; }
+	elsif ($in{'ext2_quota'} == 3)
+		{ $options{'usrquota'} = $options{'grpquota'} = ""; }
+	}
+elsif ($_[0] eq "fat" || $_[0] eq "vfat" ||
+       $_[0] eq "msdos" || $_[0] eq "umsdos") {
+	# All dos-based filesystems have similar options
+	delete($options{"uid"}); delete($options{"gid"});
+	if ($in{fat_uid} ne "") { $options{"uid"} = getpwnam($in{'fat_uid'}); }
+	if ($in{fat_gid} ne "") { $options{"gid"} = getgrnam($in{'fat_gid'}); }
+
+	delete($options{"check"});
+	if ($in{fat_check} ne "") { $options{"check"} = $in{fat_check}; }
+
+	delete($options{"conv"});
+	if ($in{fat_conv} ne "") { $options{"conv"} = $in{fat_conv}; }
+
+	delete($options{"umask"});
+	if (!$in{fat_umask_def}) {
+		$in{fat_umask} =~ /^[0-7]{3}$/ ||
+			&error(&text('linux_emask', $in{'fat_umask'}));
+		$options{"umask"} = $in{fat_umask};
+		}
+
+	delete($options{"quiet"});
+	if ($in{fat_quiet}) {
+		$options{"quiet"} = "";
+		}
+
+	if ($_[0] eq "vfat") {
+		# Parse extra vfat options..
+		delete($options{"uni_xlate"});
+		if ($in{fat_uni_xlate}) { $options{"uni_xlate"} = ""; }
+
+		delete($options{"posix"});
+		if ($in{fat_posix}) { $options{"posix"} = ""; }
+		}
+	}
+elsif ($_[0] eq "hpfs") {
+	# OS/2 filesystem options..
+	delete($options{"uid"}); delete($options{"gid"});
+	if ($in{hpfs_uid} ne "") { $options{"uid"} = getpwnam($in{hpfs_uid}); }
+	if ($in{hpfs_gid} ne "") { $options{"gid"} = getgrnam($in{hpfs_gid}); }
+
+	delete($options{"umask"});
+	if (!$in{hpfs_umask_def}) {
+		$in{hpfs_umask} =~ /^[0-7]{3}$/ ||
+			&error(&text('linux_emask', $in{'hpfs_umask'}));
+		$options{"umask"} = $in{hpfs_umask};
+		}
+
+	delete($options{"conv"});
+	if ($in{hpfs_conv} ne "") { $options{"conv"} = $in{hpfs_conv}; }
+	}
+elsif ($_[0] eq "iso9660") {
+	# Options for iso9660 cd-roms
+	delete($options{"uid"}); delete($options{"gid"});
+	if ($in{iso9660_uid} ne "")
+		{ $options{"uid"} = getpwnam($in{iso9660_uid}); }
+	if ($in{iso9660_gid} ne "")
+		{ $options{"gid"} = getgrnam($in{iso9660_gid}); }
+
+	delete($options{"norock"});
+	if ($in{iso9660_norock}) { $options{"norock"} = ""; }
+
+	delete($options{"mode"});
+	$in{iso9660_mode} =~ /^[0-7]{3}$/ ||
+		&error(&text('linux_emask', $in{'iso9660_mode'}));
+	$options{"mode"} = $in{iso9660_mode};
+	}
+elsif ($_[0] eq "autofs") {
+	# Options for automounter filesystems
+	delete($options{'timeout'});
+	if (!$in{'autofs_timeout_def'}) {
+		$in{'autofs_timeout'} =~ /^\d+$/ ||
+			&error(&text('linux_etimeout', $in{'autofs_timeout'}));
+		$options{'timeout'} = $in{'autofs_timeout'};
+		}
+	delete($options{'pid-file'});
+	if (!$in{'autofs_pid-file_def'}) {
+		$in{'autofs_pid-file'} =~ /^\/\S+$/ ||
+		       &error(&text('linux_epidfile', $in{'autofs_pid-file'}));
+		$options{'pid-file'} = $in{'autofs_pid-file'};
+		}
+	}
+elsif ($_[0] eq "smbfs") {
+	# Options for smb filesystems..
+	delete($options{'user'}); delete($options{'username'});
+	if ($in{smbfs_user}) {
+		$options{$smbfs_support == 4 ? 'username' : 'user'} = $in{smbfs_user};
+		}
+
+	delete($options{'passwd'}); delete($options{'password'});
+	if ($in{smbfs_passwd}) {
+		$options{$smbfs_support == 4 ? 'password' : 'passwd'} = $in{smbfs_passwd};
+		}
+
+	if ($smbfs_support != 2) {
+		delete($options{uid});
+		if ($in{smbfs_uid} ne "") { $options{uid} = getpwnam($in{smbfs_uid}); }
+
+		delete($options{gid});
+		if ($in{smbfs_gid} ne "") { $options{gid} = getgrnam($in{smbfs_gid}); }
+		}
+
+	if ($smbfs_support == 1) {
+		delete($options{servername});
+		if (!$in{smbfs_sname_def})
+			{ $options{servername} = $in{smbfs_sname}; }
+		}
+	elsif ($smbfs_support == 2) {
+		delete($options{workgroup});
+		if (!$in{smbfs_wg_def})
+			{ $options{workgroup} = $in{smbfs_wg}; }
+		}
+
+	if ($smbfs_support < 3) {
+		delete($options{clientname});
+		if (!$in{smbfs_cname_def})
+			{ $options{clientname} = $in{smbfs_cname}; }
+
+		delete($options{machinename});
+		if (!$in{smbfs_mname_def})
+			{ $options{machinename} = $in{smbfs_mname}; }
+		elsif (!gethostbyname($in{'smbfs_server'})) {
+			# No hostname found for the server.. try to guess
+			local($out, $sname);
+			$sname = $in{'smbfs_server'};
+			$out = `$config{'nmblookup_path'} -d 0 $sname 2>&1`;
+			if (!$? && $out =~ /^([0-9\.]+)\s+$sname\n/) {
+				$options{machinename} = $1;
+				}
+			}
+		}
+
+	if ($smbfs_support == 1) {
+		delete($options{fmode});
+		if ($in{smbfs_fmode} !~ /^[0-7]{3}$/) {
+			&error(&text('linux_efmode', $in{'smbfs_fmode'}));
+			}
+		elsif ($in{smbfs_fmode} ne "755")
+			{ $options{fmode} = $in{smbfs_fmode}; }
+
+		delete($options{dmode});
+		if ($in{smbfs_dmode} !~ /^[0-7]{3}$/) {
+			&error(&text('linux_edmode', $in{'smbfs_dmode'}));
+			}
+		elsif ($in{smbfs_dmode} ne "755")
+			{ $options{dmode} = $in{smbfs_dmode}; }
+		}
+	elsif ($smbfs_support >= 3) {
+		delete($options{'ro'}); delete($options{'rw'});
+		if ($in{'ro'}) { $options{'ro'} = ''; }
+		}
+	}
+elsif ($_[0] eq "reiserfs") {
+	# Save reiserfs options
+	delete($options{'notail'});
+	$options{'notail'} = "" if ($in{'lnx_notail'});
+	}
+
+# Add loop option if mounting a normal file
+if ($_[0] ne "swap" && $_[0] ne "auto" && $_[0] ne "autofs" &&
+    $_[0] ne "smbfs" && $_[0] ne "nfs") {
+	local(@st);
+	@st = stat($_[1]);
+	if (@st && ($st[2] & 0xF000) == 0x8000) {
+		# a regular file.. add the loop option
+		if (!$options{'loop'}) {
+			$options{'loop'} = "";
+			}
+		}
+	}
+
+# Return options string
+foreach $k (keys %options) {
+	if ($options{$k} eq "") { push(@rv, $k); }
+	else { push(@rv, "$k=$options{$k}"); }
+	}
+return @rv ? join(',' , @rv) : "-";
+}
+
+
+# Get the smbfs options from 'smbfs_opts' file in the current directory. This
+# is sadly necessary because there is no way to get the current options for
+# an existing smbfs mount... so webmin has to save them in a file when
+# mounting. Blech.
+sub read_smbopts
+{
+local($_);
+open(SMBOPTS, "$module_config_directory/smbfs");
+while(<SMBOPTS>) {
+	/^(\S+)\s+(\S+)$/;
+	$smbopts{$1} = $2;
+	}
+close(SMBOPTS);
+}
+
+sub write_smbopts
+{
+local($_);
+open(SMBOPTS, "> $module_config_directory/smbfs");
+foreach (keys %smbopts) {
+	print SMBOPTS "$_\t$smbopts{$_}\n";
+	}
+close(SMBOPTS);
+}
+
+
+# create_swap(file, size, units)
+# Calls dd and mkswap to setup a swap file
+sub create_swap
+{
+local($out, $bl);
+$bl = $_[1] * ($_[2] eq "m" ? 1024 : 1);
+$out = `dd if=/dev/zero of=$_[0] bs=1024 count=$bl 2>&1`;
+if ($?) { return "dd failed : $out"; }
+$out = `mkswap $_[0] $bl 2>&1`;
+if ($?) { return "mkswap failed : $out"; }
+system("sync >/dev/null 2>&1");
+return 0;
+}
+
+# exports_list(host, dirarray, clientarray)
+# Fills the directory and client array references with exports from some
+# host. Returns an error string if something went wrong
+sub exports_list
+{
+local($dref, $cref, $out, $_);
+$dref = $_[1]; $cref = $_[2];
+$out = `showmount -e $_[0] 2>&1`;
+if ($?) { return $out; }
+foreach (split(/\n/, $out)) {
+	if (/^(\/\S*)\s+(.*)$/) {
+		push(@$dref, $1); push(@$cref, $2);
+		}
+	}
+return undef;
+}
+
+# broadcast_addr()
+# Returns a useable broadcast address for finding NFS servers
+sub broadcast_addr
+{
+local($out);
+$out = `ifconfig -a 2>&1`;
+if ($out =~ /(eth|tr)\d\s+.*\n.*Bcast:(\S+)\s+/) { return $2; }
+return "255.255.255.255";
+}
+
+# autofs_options(string)
+# Converts a string of options line --timeout 60 to something like timeout=60
+sub autofs_options
+{
+local(@options);
+if ($_[0] =~ /--timeout\s+(\d+)/ || $_[0] =~ /-t\s+(\d+)/) {
+	push(@options, "timeout=$1");
+	}
+if ($_[0] =~ /--pid-file\s+(\S+)/ || $_[0] =~ /-p\s+(\d+)/) {
+	push(@options, "pid-file=$1");
+	}
+return join(',', @options);
+}
+
+# autofs_args(string)
+# Convert a comma-separated options string into args for automount
+sub autofs_args
+{
+local(%options, $args);
+&parse_options("autofs", $_[0]);
+if (defined($options{'timeout'})) {
+	$args .= " --timeout $options{'timeout'}";
+	}
+if (defined($options{'pid-file'})) {
+	$args .= " --pid-file $options{'pid-file'}";
+	}
+return $args;
+}
+
+# read_amd_conf()
+# Returns the entire amd config file as a string
+sub read_amd_conf
+{
+local $sl = $/;
+$/ = undef;
+open(AMD, $config{'auto_file'});
+local $rv = <AMD>;
+close(AMD);
+$/ = $sl;
+return $rv;
+}
+
+# write_amd_conf(text)
+sub write_amd_conf
+{
+open(AMD, ">$config{'auto_file'}");
+print AMD $_[0];
+close(AMD);
+}
+
+# parse_amd_conf()
+# Parses a new-style amd.conf file into a hashtable
+sub parse_amd_conf
+{
+local (@rv, $str, $lnum);
+open(AMD, $config{'auto_file'});
+while(<AMD>) {
+	s/\r|\n//g;
+	s/#*$//g;
+	if (/\[\s*(\S+)\s*\]/) {
+		$str = { 'dir' => $1,
+			 'line' => $lnum,
+			 'eline' => $lnum };
+		push(@rv, $str);
+		}
+	elsif (/(\S+)\s*=\s*"(.*)"/ || /(\S+)\s*=\s*(\S+)/) {
+		$str->{'opts'}->{$1} = $2;
+		$str->{'eline'} = $lnum;
+		}
+	$lnum++;
+	}
+close(AMD);
+return @rv;
+}
+
+# device_name(device)
+# Converts a device name to a human-readable form
+sub device_name
+{
+if (!$text{'select_part'}) {
+	local %flang = &load_language('fdisk');
+	$text{'select_part'} = $flang{'select_part'};
+	$text{'select_mpart'} = $flang{'select_mpart'};
+	$text{'select_device'} = $flang{'select_device'};
+	$text{'select_fd'} = $flang{'select_fd'};
+	}
+return $_[0] =~ /^\/dev\/(s|h)d([a-z])(\d+)$/ ?
+	&text('select_part', $1 eq 's' ? 'SCSI' : 'IDE', uc($2), "$3") :
+       $_[0] =~ /^\/dev\/(s|h)d([a-z])$/ ?
+	&text('select_device', $1 eq 's' ? 'SCSI' : 'IDE', uc($2)) :
+       $_[0] =~ /rd\/c(\d+)d(\d+)p(\d+)$/ ?
+	&text('select_mpart', "$1", "$2", "$3") :
+       $_[0] =~ /fd(\d+)$/ ?
+	&text('select_fd', "$1") :
+       $_[0] =~ /md(\d+)$/ ?
+	&text('linux_rdev', "$1") :
+	$_[0];
+}
+
+1;
+
diff -uNr webmin-0.990.orig/mysql/config-pld-linux webmin-0.990/mysql/config-pld-linux
--- webmin-0.990.orig/mysql/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/mysql/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,7 @@
+start_cmd=/etc/rc.d/init.d/mysql start
+stop_cmd=/etc/rc.d/init.d/mysql stop
+mysql=/usr/bin/mysql
+mysql_libs=
+mysqladmin=/usr/bin/mysqladmin
+mysqlshow=/usr/bin/mysqlshow
+perpage=25
diff -uNr webmin-0.990.orig/net/config-pld-linux webmin-0.990/net/config-pld-linux
--- webmin-0.990.orig/net/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/net/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1 @@
+hosts_file=/etc/hosts
diff -uNr webmin-0.990.orig/net/pld-linux-lib.pl webmin-0.990/net/pld-linux-lib.pl
--- webmin-0.990.orig/net/pld-linux-lib.pl	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/net/pld-linux-lib.pl	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,458 @@
+# pld-linux-lib.pl
+# Networking functions for PLD Linux
+
+$net_scripts_dir = "/etc/sysconfig/interfaces";
+$network_config = "/etc/sysconfig/network";
+$static_route_config = "/etc/sysconfig/static-routes";
+
+# active_interfaces()
+# Returns a list of currently ifconfig'd interfaces
+sub active_interfaces
+{
+local(@rv, @lines, $l);
+open(IFC, "ifconfig -a |");
+while(<IFC>) {
+	s/\r|\n//g;
+	if (/^\S+/) { push(@lines, $_); }
+	else { $lines[$#lines] .= $_; }
+	}
+close(IFC);
+foreach $l (@lines) {
+	local %ifc;
+	$l =~ /^([^:\s]+)/; $ifc{'name'} = $1;
+	$l =~ /^(\S+)/; $ifc{'fullname'} = $1;
+	if ($l =~ /^(\S+):(\d+)/) { $ifc{'virtual'} = $2; }
+	if ($l =~ /inet addr:(\S+)/) { $ifc{'address'} = $1; }
+	elsif (!$_[0]) { next; }
+	if ($l =~ /Mask:(\S+)/) { $ifc{'netmask'} = $1; }
+	if ($l =~ /Bcast:(\S+)/) { $ifc{'broadcast'} = $1; }
+	if ($l =~ /HWaddr (\S+)/) { $ifc{'ether'} = $1; }
+	if ($l =~ /MTU:(\d+)/) { $ifc{'mtu'} = $1; }
+	$ifc{'up'}++ if ($l =~ /\sUP\s/);
+	$ifc{'edit'} = ($ifc{'name'} !~ /^ppp/);
+	$ifc{'index'} = scalar(@rv);
+	push(@rv, \%ifc);
+	}
+return @rv;
+}
+
+# activate_interface(&details)
+# Create or modify an interface
+sub activate_interface
+{
+local $a = $_[0];
+local $cmd = "ifconfig $a->{'name'}";
+if ($a->{'virtual'} ne "") { $cmd .= ":$a->{'virtual'}"; }
+$cmd .= " $a->{'address'}";
+if ($a->{'netmask'}) { $cmd .= " netmask $a->{'netmask'}"; }
+if ($a->{'broadcast'}) { $cmd .= " broadcast $a->{'broadcast'}"; }
+if ($a->{'mtu'}) { $cmd .= " mtu $a->{'mtu'}"; }
+if ($a->{'up'}) { $cmd .= " up"; }
+else { $cmd .= " down"; }
+local $out = `$cmd 2>&1`;
+if ($?) { &error($out); }
+if ($a->{'ether'}) {
+	$out = `ifconfig $a->{'name'} hw ether $a->{'ether'} 2>&1`;
+	if ($?) { &error($out); }
+	}
+}
+
+# deactivate_interface(&details)
+# Shutdown some active interface
+sub deactivate_interface
+{
+local $name = $_[0]->{'name'}.
+	      ($_[0]->{'virtual'} ne "" ? ":$_[0]->{'virtual'}" : "");
+if ($_[0]->{'virtual'} ne "") {
+	# Shutdown virtual interface by setting address to 0
+	local $out = `ifconfig $name 0 2>&1`;
+	if ($?) { &error($out); }
+	}
+local ($still) = grep { $_->{'fullname'} eq $name } &active_interfaces();
+if ($still) {
+	# Old version of ifconfig or non-virtual interface.. down it
+	local $out = `ifconfig $name down 2>&1`;
+	&error("ifconfig $name down");
+	if ($?) { &error($out); }
+	}
+}
+
+# boot_interfaces()
+# Returns a list of interfaces brought up at boot time
+sub boot_interfaces
+{
+local(@rv, $f);
+opendir(CONF, $net_scripts_dir);
+while($f = readdir(CONF)) {
+	next if ($f !~ /^ifcfg-\S+/);
+	local (%conf, $b);
+	&read_env_file("$net_scripts_dir/$f", \%conf);
+	$b->{'fullname'} = $conf{'DEVICE'};
+	if ($b->{'fullname'} =~ /(\S+):(\d+)/) {
+		$b->{'name'} = $1;
+		$b->{'virtual'} = $2;
+		}
+	else { $b->{'name'} = $b->{'fullname'}; }
+	$b->{'up'} = ($conf{'ONBOOT'} eq 'yes');
+	$b->{'address'} = $conf{'IPADDR'};
+	$b->{'netmask'} = $conf{'NETMASK'};
+	$b->{'broadcast'} = $conf{'BROADCAST'};
+	$b->{'dhcp'} = ($conf{'BOOTPROTO'} eq 'dhcp');
+	$b->{'bootp'} = ($conf{'BOOTPROTO'} eq 'bootp');
+	$b->{'edit'} = ($b->{'name'} !~ /^ppp/);
+	$b->{'index'} = scalar(@rv);
+	push(@rv, $b);
+	}
+closedir(CONF);
+return @rv;
+}
+
+# save_interface(&details)
+# Create or update a boot-time interface
+sub save_interface
+{
+local(%conf);
+local $name = $_[0]->{'virtual'} ne "" ? $_[0]->{'name'}.":".$_[0]->{'virtual'}
+				       : $_[0]->{'name'};
+&read_env_file("$net_scripts_dir/ifcfg-$name", \%conf);
+$conf{'DEVICE'} = $name;
+$conf{'IPADDR'} = $_[0]->{'address'};
+local($ip1, $ip2, $ip3, $ip4) = split(/\./, $_[0]->{'address'});
+$conf{'NETMASK'} = $_[0]->{'netmask'};
+local($nm1, $nm2, $nm3, $nm4) = split(/\./, $_[0]->{'netmask'});
+if ($_[0]->{'address'} && $_[0]->{'netmask'}) {
+	$conf{'NETWORK'} = sprintf "%d.%d.%d.%d",
+				($ip1 & int($nm1))&0xff,
+				($ip2 & int($nm2))&0xff,
+				($ip3 & int($nm3))&0xff,
+				($ip4 & int($nm4))&0xff;
+	}
+else {
+	$conf{'NETWORK'} = '';
+	}
+$conf{'BROADCAST'} = $_[0]->{'broadcast'};
+$conf{'ONBOOT'} = $_[0]->{'up'} ? "yes" : "no";
+$conf{'BOOTPROTO'} = $_[0]->{'bootp'} ? "bootp" :
+		     $_[0]->{'dhcp'} ? "dhcp" : "none";
+&write_env_file("$net_scripts_dir/ifcfg-$name", \%conf);
+}
+
+# delete_interface(&details)
+# Delete a boot-time interface
+sub delete_interface
+{
+local $name = $_[0]->{'virtual'} ne "" ? $_[0]->{'name'}.":".$_[0]->{'virtual'}
+				       : $_[0]->{'name'};
+unlink("$net_scripts_dir/ifcfg-$name");
+}
+
+# iface_type(name)
+# Returns a human-readable interface type name
+sub iface_type
+{
+return "PPP" if ($_[0] =~ /^ppp/);
+return "SLIP" if ($_[0] =~ /^sl/);
+return "PLIP" if ($_[0] =~ /^plip/);
+return "Ethernet" if ($_[0] =~ /^eth/);
+return "Arcnet" if ($_[0] =~ /^arc/);
+return "Token Ring" if ($_[0] =~ /^tr/);
+return "Pocket/ATP" if ($_[0] =~ /^atp/);
+return "Loopback" if ($_[0] =~ /^lo/);
+return "Unknown";
+}
+
+# iface_hardware(name)
+# Does some interface have an editable hardware address
+sub iface_hardware
+{
+return $_[0] =~ /^eth/;
+}
+
+# can_edit(what)
+# Can some boot-time interface parameter be edited?
+sub can_edit
+{
+return $_[0] ne "mtu";
+}
+
+# valid_boot_address(address)
+# Is some address valid for a bootup interface
+sub valid_boot_address
+{
+return &check_ipaddress($_[0]);
+}
+
+# get_dns_config()
+# Returns a hashtable containing keys nameserver, domain, search & order
+sub get_dns_config
+{
+local $dns;
+open(RESOLV, "/etc/resolv.conf");
+while(<RESOLV>) {
+	s/\r|\n//g;
+	if (/nameserver\s+(.*)/) {
+		push(@{$dns->{'nameserver'}}, split(/\s+/, $1));
+		}
+	elsif (/domain\s+(\S+)/) {
+		$dns->{'domain'} = [ $1 ];
+		}
+	elsif (/search\s+(.*)/) {
+		$dns->{'domain'} = [ split(/\s+/, $1) ];
+		}
+	}
+close(RESOLV);
+open(SWITCH, "/etc/nsswitch.conf");
+while(<SWITCH>) {
+	s/\r|\n//g;
+	if (/^\s*hosts:\s+(.*)/) {
+		$dns->{'order'} = $1;
+		}
+	}
+close(SWITCH);
+return $dns;
+}
+
+# save_dns_config(&config)
+# Writes out the resolv.conf and nsswitch.conf files
+sub save_dns_config
+{
+open(RESOLV, "/etc/resolv.conf");
+local @resolv = <RESOLV>;
+close(RESOLV);
+open(RESOLV, ">/etc/resolv.conf");
+foreach (@{$_[0]->{'nameserver'}}) {
+	print RESOLV "nameserver $_\n";
+	}
+if ($_[0]->{'domain'}) {
+	if ($_[0]->{'domain'}->[1]) {
+		print RESOLV "search ",join(" ", @{$_[0]->{'domain'}}),"\n";
+		}
+	else {
+		print RESOLV "domain $_[0]->{'domain'}->[0]\n";
+		}
+	}
+foreach (@resolv) {
+	print RESOLV $_ if (!/^\s*(nameserver|domain|search)\s+/);
+	}
+close(RESOLV);
+
+open(SWITCH, "/etc/nsswitch.conf");
+local @switch = <SWITCH>;
+close(SWITCH);
+open(SWITCH, ">/etc/nsswitch.conf");
+foreach (@switch) {
+	if (/^\s*hosts:\s+/) {
+		print SWITCH "hosts:\t$_[0]->{'order'}\n";
+		}
+	else { print SWITCH $_; }
+	}
+close(SWITCH);
+}
+
+$max_dns_servers = 3;
+
+# order_input(&dns)
+# Returns HTML for selecting the name resolution order
+sub order_input
+{
+if ($_[0]->{'order'} =~ /\[/) {
+	# Using a complex resolve list
+	return "<input name=order size=45 value=\"$_[0]->{'order'}\">\n";
+	}
+else {
+	# Can select by menus
+	local @o = split(/\s+/, $_[0]->{'order'});
+	@o = map { s/nis\+/nisplus/; s/yp/nis/; $_; } @o;
+	local ($rv, $i, $j);
+	local @srcs = ( "", "files", "dns", "nis", "nisplus", "db" );
+	local @srcn = ( "", "Hosts", "DNS", "NIS", "NIS+", "DB" );
+	for($i=1; $i<@srcs; $i++) {
+		local $ii = $i-1;
+		$rv .= "<select name=order_$ii>\n";
+		for($j=0; $j<@srcs; $j++) {
+			$rv .= sprintf "<option value=\"%s\" %s>%s\n",
+					$srcs[$j],
+					$o[$ii] eq $srcs[$j] ? "selected" : "",
+					$srcn[$j];
+			}
+		$rv .= "</select>\n";
+		}
+	return $rv;
+	}
+}
+
+# parse_order(&dns)
+# Parses the form created by order_input()
+sub parse_order
+{
+if (defined($in{'order'})) {
+	$in{'order'} =~ /\S/ || &error($text{'dns_eorder'});
+	$_[0]->{'order'} = $in{'order'};
+	}
+else {
+	local($i, @order);
+	for($i=0; defined($in{"order_$i"}); $i++) {
+		push(@order, $in{"order_$i"}) if ($in{"order_$i"});
+		}
+	$_[0]->{'order'} = join(" ", @order);
+	}
+}
+
+# get_hostname()
+sub get_hostname
+{
+return &get_system_hostname();
+}
+
+# save_hostname(name)
+sub save_hostname
+{
+local %conf;
+system("hostname $_[0] >/dev/null 2>&1");
+open(HOST, ">/etc/HOSTNAME");
+print HOST $_[0],"\n";
+close(HOST);
+&read_env_file($network_config, \%conf);
+$conf{'HOSTNAME'} = $_[0];
+&write_env_file($network_config, \%conf);
+}
+
+# get_domainname()
+sub get_domainname
+{
+local $d = `domainname`;
+chop($d);
+return $d eq "(none)" ? "" : $d;
+}
+
+# save_domainname(domain)
+sub save_domainname
+{
+local %conf;
+system("domainname \"$_[0]\" >/dev/null 2>&1");
+&read_env_file($network_config, \%conf);
+if ($_[0]) {
+	$conf{'NISDOMAIN'} = $_[0];
+	}
+else {
+	delete($conf{'NISDOMAIN'});
+	}
+&write_env_file($network_config, \%conf);
+}
+
+sub routing_input
+{
+# show default router and device
+local (%conf, @st, @hr);
+&read_env_file($network_config, \%conf);
+print "<tr> <td><b>$text{'routes_default'}</b></td> <td>\n";
+printf "<input type=radio name=gateway_def value=1 %s> $text{'routes_none'}\n",
+	$conf{'GATEWAY'} ? "" : "checked";
+printf "<input type=radio name=gateway_def value=0 %s>\n",
+	$conf{'GATEWAY'} ? "checked" : "";
+printf "<input name=gateway size=15 value=\"%s\"></td> </tr>\n",
+	$conf{'GATEWAY'};
+
+print "<tr> <td><b>$text{'routes_device2'}</b></td> <td>\n";
+printf "<input type=radio name=gatewaydev_def value=1 %s> $text{'routes_none'}\n",
+	$conf{'GATEWAYDEV'} ? "" : "checked";
+printf "<input type=radio name=gatewaydev_def value=0 %s>\n",
+	$conf{'GATEWAYDEV'} ? "checked" : "";
+printf "<input name=gatewaydev size=6 value=\"%s\"></td> </tr>\n",
+	$conf{'GATEWAYDEV'};
+
+# show routing
+print "<tr> <td><b>$text{'routes_forward'}</b></td> <td>\n";
+printf "<input type=radio name=forward value=1 %s> $text{'yes'}\n",
+	$conf{'FORWARD_IPV4'} eq "yes" ? "checked" : "";
+printf "<input type=radio name=forward value=0 %s> $text{'no'}</td> </tr>\n",
+	$conf{'FORWARD_IPV4'} eq "yes" ? "" : "checked";
+
+# get static routes
+open(STATIC, $static_route_config);
+while(<STATIC>) {
+	if (/(\S+)\s+net\s+(\S+)\s+netmask\s+(\S+)\s+gw\s+(\S+)/) {
+		push(@st, [ $1, $2, $3, $4 ]);
+		}
+	elsif (/(\S+)\s+host\s+(\S+)/) {
+		push(@hr, [ $1, $2 ]);
+		}
+	}
+close(STATIC);
+
+# show static network routes
+print "<tr> <td valign=top><b>$text{'routes_static'}</b></td>\n";
+print "<td><table border>\n";
+print "<tr $tb> <td><b>$text{'routes_ifc'}</b></td> ",
+      "<td><b>$text{'routes_net'}</b></td> ",
+      "<td><b>$text{'routes_mask'}</b></td> ",
+      "<td><b>$text{'routes_gateway'}</b></td> </tr>\n";
+for($i=0; $i<=@st; $i++) {
+	local $st = $st[$i];
+	print "<tr $cb>\n";
+	print "<td><input name=dev_$i size=6 value='$st->[0]'></td>\n";
+	print "<td><input name=net_$i size=15 value='$st->[1]'></td>\n";
+	print "<td><input name=netmask_$i size=15 value='$st->[2]'></td>\n";
+	print "<td><input name=gw_$i size=15 value='$st->[3]'></td>\n";
+	print "</tr>\n";
+	}
+print "</table></td> </tr>\n";
+
+# Show static host routes
+print "<tr> <td valign=top><b>$text{'routes_local'}</b></td>\n";
+print "<td><table border>\n";
+print "<tr $tb> <td><b>$text{'routes_ifc'}</b></td> ",
+      "<td><b>$text{'routes_net'}</b></td> </tr>\n";
+for($i=0; $i<=@hr; $i++) {
+	local $st = $hr[$i];
+	print "<tr $cb>\n";
+	print "<td><input name=ldev_$i size=6 value='$st->[0]'></td>\n";
+	print "<td><input name=lnet_$i size=15 value='$st->[1]'></td>\n";
+	print "</tr>\n";
+	}
+print "</table></td> </tr>\n";
+}
+
+sub parse_routing
+{
+local (%conf, @st);
+&read_env_file($network_config, \%conf);
+if ($in{'gateway_def'}) { $conf{'GATEWAY'} = ''; }
+elsif (!gethostbyname($in{'gateway'})) {
+	&error(&text('routes_edefault', $in{'gateway'}));
+	}
+else { $conf{'GATEWAY'} = $in{'gateway'}; }
+
+if ($in{'gatewaydev_def'}) { $conf{'GATEWAYDEV'} = ''; }
+elsif ($in{'gatewaydev'} !~ /^\S+$/) {
+	&error(&text('routes_edevice', $in{'gatewaydev'}));
+	}
+else { $conf{'GATEWAYDEV'} = $in{'gatewaydev'}; }
+
+if ($in{'forward'}) { $conf{'FORWARD_IPV4'} = 'yes'; }
+else { $conf{'FORWARD_IPV4'} = 'no'; }
+
+for($i=0; defined($dev = $in{"dev_$i"}); $i++) {
+	$net = $in{"net_$i"}; $netmask = $in{"netmask_$i"}; $gw = $in{"gw_$i"};
+	next if (!$dev && !$net && !$netmask && !$gw);
+	$dev =~ /^\S+$/ || &error(&text('routes_edevice', $dev));
+	gethostbyname($net) || &error(&text('routes_enet', $net));
+	&check_ipaddress($netmask) || &error(&text('routes_emask', $netmask));
+	gethostbyname($gw) || &error(&text('routes_egateway', $gw));
+	push(@st, "$dev net $net netmask $netmask gw $gw\n");
+	}
+for($i=0; defined($dev = $in{"ldev_$i"}); $i++) {
+	$net = $in{"lnet_$i"};
+	next if (!$dev && !$net);
+	$dev =~ /^\S+$/ || &error(&text('routes_edevice', $dev));
+	gethostbyname($net) || &error(&text('routes_enet', $net));
+	push(@st, "$dev host $net\n");
+	}
+open(STATIC, ">$static_route_config");
+print STATIC @st;
+close(STATIC);
+&write_env_file($network_config, \%conf);
+}
+
+1;
+
diff -uNr webmin-0.990.orig/os_list.txt webmin-0.990/os_list.txt
--- webmin-0.990.orig/os_list.txt	Mon Jul  1 07:03:51 2002
+++ webmin-0.990/os_list.txt	Mon Jul  1 11:18:40 2002
@@ -113,6 +113,7 @@
 Yellow Dog Linux		2.1	redhat-linux	7.1	$etc_issue =~ /Yellow\s+Dog\s+Linux\s+release\s+2\.1\s+/i || `cat /etc/yellowdog-release 2>&1` =~ /Yellow\s+Dog\s+Linux\s+release\s+2\.1\s+/i
 Yellow Dog Linux		2.2	redhat-linux	7.2	$etc_issue =~ /Yellow\s+Dog\s+Linux\s+release\s+2\.2\s+/i || `cat /etc/yellowdog-release 2>&1` =~ /Yellow\s+Dog\s+Linux\s+release\s+2\.2\s+/i
 Corvus Latinux			8.0	redhat-linux	7.1	`cat /etc/latinux-release 2>&1` =~ /Latinux\s+8\s/i
+PLD Linux			2.0	pld-linux	2.0	`cat /etc/pld-release 2>&1` =~ /2\.0/
 Immunix Linux			6.2	redhat-linux	6.2	$etc_issue =~ /Immunix.*\s6\.2/i || `cat /etc/immunix-release 2>&1` =~ /6\.2/
 Immunix Linux			7.0	redhat-linux	7.0	$etc_issue =~ /Immunix.*\s7\.0/i || `cat /etc/immunix-release 2>&1` =~ /7\.0/
 Gentoo Linux			Any version	gentoo-linux	*	-d "/usr/portage"
diff -uNr webmin-0.990.orig/pam/module.info webmin-0.990/pam/module.info
--- webmin-0.990.orig/pam/module.info	Mon Jul  1 07:04:42 2002
+++ webmin-0.990/pam/module.info	Mon Jul  1 11:23:52 2002
@@ -2,7 +2,7 @@
 risk=high
 desc_ko_KR.euc=PAM 檣隸
 desc_zh_TW.Big5=PAM 認證
-os_support=redhat-linux mandrake-linux open-linux debian-linux/2.2 debian-linux/3.0 corel-linux suse-linux turbo-linux cobalt-linux msc-linux generic-linux gentoo-linux
+os_support=redhat-linux mandrake-linux open-linux debian-linux/2.2 debian-linux/3.0 corel-linux suse-linux turbo-linux cobalt-linux msc-linux generic-linux gentoo-linux pld-linux
 desc=PAM Authentication
 desc_pl=Autoryzacja przez PAM
 desc_de=PAM-Authentisierung
diff -uNr webmin-0.990.orig/pap/config-pld-linux webmin-0.990/pap/config-pld-linux
--- webmin-0.990.orig/pap/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/pap/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,2 @@
+pap_file=/etc/ppp/pap-secrets
+encrypt_pass=0
diff -uNr webmin-0.990.orig/proc/config-pld-linux webmin-0.990/proc/config-pld-linux
--- webmin-0.990.orig/proc/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/proc/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,3 @@
+default_mode=last
+ps_style=linux
+base_ppid=1
diff -uNr webmin-0.990.orig/quota/config-pld-linux webmin-0.990/quota/config-pld-linux
--- webmin-0.990.orig/quota/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/quota/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,16 @@
+display_max=100
+user_grace_command=edquota -u -t
+group_grace_command=edquota -g -t
+group_quotaon_command=quotaon -g
+user_quotaoff_command=quotaoff -u
+user_quotaon_command=quotaon -u
+group_quota_command=quota -v -g
+group_copy_command=edquota -g -p
+quotacheck_command=quotacheck -u -g
+user_quota_command=quota -v -u
+user_copy_command=edquota -u -p
+group_repquota_command=repquota -g -v
+user_repquota_command=repquota -u -v
+group_edquota_command=edquota -g
+user_edquota_command=edquota -u
+group_quotaoff_command=quotaoff -g
diff -uNr webmin-0.990.orig/quota/pld-linux-lib.pl webmin-0.990/quota/pld-linux-lib.pl
--- webmin-0.990.orig/quota/pld-linux-lib.pl	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/quota/pld-linux-lib.pl	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,391 @@
+# linux-lib.pl
+# Quota functions for all linux version
+
+# quotas_init()
+sub quotas_init
+{
+if (&has_command("quotaon") && &has_command("quotaoff")) {
+	return undef;
+	}
+else {
+	return "The quota package does not appear to be installed on ".
+	       "your system\n";
+	}
+}
+
+# quotas_supported()
+# Returns 1 for user quotas, 2 for group quotas or 3 for both
+sub quotas_supported
+{
+return 3;
+}
+
+# free_space(filesystem)
+# Returns an array containing  btotal, bfree, ftotal, ffree
+sub free_space
+{
+local(@out, @rv);
+$out = `df $_[0]`;
+$out =~ /Mounted on\n\S+\s+(\d+)\s+\d+\s+(\d+)/;
+push(@rv, ($1, $2));
+$out = `df -i $_[0]`;
+$out =~ /Mounted on\n\S+\s+(\d+)\s+\d+\s+(\d+)/;
+push(@rv, ($1, $2));
+return @rv;
+}
+
+# quota_can(&mnttab, &fstab)
+# Can this filesystem type support quotas?
+#  0 = No quota support (or not turned on in /etc/fstab)
+#  1 = User quotas only
+#  2 = Group quotas only
+#  3 = User and group quotas
+sub quota_can
+{
+return ($_[1]->[3] =~ /usrquota/ ? 1 : 0) +
+       ($_[1]->[3] =~ /grpquota/ ? 2 : 0);
+}
+
+# quota_now(&mnttab, &fstab)
+# Are quotas currently active?
+#  0 = Not active
+#  1 = User quotas active
+#  2 = Group quotas active
+#  3 = Both active
+sub quota_now
+{
+local $rv = 0;
+local $dir = $_[0]->[0];
+if ($_[0]->[4]%2 == 1) {
+	# test user quotas
+	if (-r "$dir/quota.user") {
+		$out = `$config{'user_quotaon_command'} $dir 2>&1`;
+		if ($out =~ /Device or resource busy/i) {
+			# already on..
+			$rv += 1;
+			}
+		elsif ($out =~ /Package not installed/i) {
+			# No quota support!
+			return 0;
+			}
+		else {
+			# was off.. need to turn on again
+			`$config{'user_quotaoff_command'} $dir 2>&1`;
+			}
+		}
+	}
+if ($_[0]->[4] > 1) {
+	# test group quotas
+	if (-r "$dir/quota.group") {
+		$out = `$config{'group_quotaon_command'} $dir 2>&1`;
+		if ($out =~ /Device or resource busy/i) {
+			# already on..
+			$rv += 2;
+			}
+		elsif ($out =~ /Package not installed/i) {
+			# No quota support!
+			return 0;
+			}
+		else {
+			# was off.. need to turn on again
+			`$config{'group_quotaoff_command'} $dir 2>&1`;
+			}
+		}
+	}
+return $rv;
+}
+
+# quotaon(filesystem, mode)
+# Activate quotas and create quota files for some filesystem. The mode can
+# be 1 for user only, 2 for group only or 3 for user and group
+sub quotaon
+{
+local($out, $qf, @qfile, $flags);
+if ($_[1]%2 == 1) {
+	# turn on user quotas
+	$qf = "$_[0]/quota.user";
+	if (!(-r $qf)) {
+		open(QUOTAFILE, "> $qf"); close(QUOTAFILE);
+		chmod(0600, $qf);
+		system("$config{'quotacheck_command'} $_[0]");
+		}
+	$out = `$config{'user_quotaon_command'} $_[0] 2>&1`;
+	if ($?) { return $out; }
+	}
+if ($_[1] > 1) {
+	# turn on group quotas
+	$qf = "$_[0]/quota.group";
+	if (!(-r $qf)) {
+		open(QUOTAFILE, "> $qf"); close(QUOTAFILE);
+		chmod(0600, $qf);
+		system("$config{'quotacheck_command'} $_[0]");
+		}
+	$out = `$config{'group_quotaon_command'} $_[0] 2>&1`;
+	if ($?) { return $out; }
+	}
+return undef;
+}
+
+# quotaoff(filesystem, mode)
+# Turn off quotas for some filesystem
+sub quotaoff
+{
+local($out);
+if ($_[1]%2 == 1) {
+	$out = `$config{'user_quotaoff_command'} $_[0] 2>&1`;
+	if ($?) { return $out; }
+	}
+if ($_[1] > 1) {
+	$out = `$config{'group_quotaoff_command'} $_[0] 2>&1`;
+	if ($?) { return $out; }
+	}
+return undef;
+}
+
+# user_filesystems(user)
+# Fills the array %filesys with details of all filesystem some user has
+# quotas on
+sub user_filesystems
+{
+return &parse_quota_output("$config{'user_quota_command'} $_[0]");
+}
+
+# user_filesystems(user)
+# Fills the array %filesys with details of all filesystem some group has
+# quotas on
+sub group_filesystems
+{
+return &parse_quota_output("$config{'group_quota_command'} $_[0]");
+}
+
+sub parse_quota_output
+{
+local($n, $_, %mtab);
+open(MTAB, "/etc/mtab");
+while(<MTAB>) {
+	@m = split(/\s+/);
+	$mtab{$m[0]} = $m[1];
+	}
+close(MTAB);
+open(QUOTA, "$_[0] |");
+$n=0; while(<QUOTA>) {
+	chop;
+	if (/^(Disk|\s+Filesystem)/) { next; }
+	if (/^(\S+)$/) {
+		# Bogus wrapped line
+		$filesys{$n,'filesys'} = $mtab{$1};
+		<QUOTA>=~/^.{15}.(.{7}).(.{7}).(.{7}).{8}.(.{7}).(.{7}).(.{7})/;
+		$filesys{$n,'ublocks'} = int($1);
+		$filesys{$n,'sblocks'} = int($2);
+		$filesys{$n,'hblocks'} = int($3);
+		$filesys{$n,'ufiles'} = int($4);
+		$filesys{$n,'sfiles'} = int($5);
+		$filesys{$n,'hfiles'} = int($6);
+		$n++;
+		}
+	elsif (/^(.{15}).(.{7}).(.{7}).(.{7}).{8}.(.{7}).(.{7}).(.{7})/) {
+		$filesys{$n,'ublocks'} = int($2);
+		$filesys{$n,'sblocks'} = int($3);
+		$filesys{$n,'hblocks'} = int($4);
+		$filesys{$n,'ufiles'} = int($5);
+		$filesys{$n,'sfiles'} = int($6);
+		$filesys{$n,'hfiles'} = int($7);
+		$dev = $1; $dev =~ s/\s+$//g; $dev =~ s/^\s+//g;
+		$filesys{$n,'filesys'} = $mtab{$dev};
+		$n++;
+		}
+	}
+close(QUOTA);
+return $n;
+}
+
+# filesystem_users(filesystem)
+# Fills the array %user with information about all users with quotas
+# on this filesystem. This may not be all users on the system..
+sub filesystem_users
+{
+return &parse_repquota_output(
+	"$config{'user_repquota_command'} $_[0]", "user");
+}
+
+sub filesystem_groups
+{
+return &parse_repquota_output(
+	"$config{'group_repquota_command'} $_[0]", "group");
+}
+
+sub parse_repquota_output
+{
+local($rep, @rep, $n, $what, $u, @uinfo);
+$what = $_[1];
+$rep = `$_[0] 2>&1`;
+if ($?) { return -1; }
+if ($what eq 'user') {
+	setpwent();
+	while(@uinfo = getpwent()) {
+		$hasu{$uinfo[0]}++;
+		}
+	endpwent();
+	}
+else {
+	setgrent();
+	while(@uinfo = getgrent()) {
+		$hasu{$uinfo[0]}++;
+		}
+	endgrent();
+	}
+@rep = split(/\n/, $rep); @rep = @rep[3..$#rep];
+for($n=0; $n<@rep; $n++) {
+	if ($rep[$n] =~ /(\S+)\s*[\-\+]{2}(.{8})(.{8})(.{8}).{7}(.{8})(.{8})(.{8})/) {
+		$$what{$n,$what} = $1;
+		$$what{$n,'ublocks'} = int($2);
+		$$what{$n,'sblocks'} = int($3);
+		$$what{$n,'hblocks'} = int($4);
+		$$what{$n,'ufiles'} = int($5);
+		$$what{$n,'sfiles'} = int($6);
+		$$what{$n,'hfiles'} = int($7);
+		if ($$what{$n,$what} !~ /^\d+$/ && !$hasu{$$what{$n,$what}}) {
+			# User/group name was truncated! Try to find him..
+			foreach $u (keys %hasu) {
+				if (substr($u, 0, length($$what{$n,$what})) eq
+				    $$what{$n,$what}) {
+					# found him..
+					$$what{$n,$what} = $u;
+					last;
+					}
+				}
+			}
+		}
+	}
+return $n;
+}
+
+# edit_quota_file(data, filesys, sblocks, hblocks, sfiles, hfiles)
+sub edit_quota_file
+{
+local($rv, $line, %mtab, @m);
+open(MTAB, "/etc/mtab");
+while(<MTAB>) {
+	@m = split(/\s+/);
+	$mtab{$m[0]} = $m[1];
+	}
+close(MTAB);
+@line = split(/\n/, $_[0]);
+for($i=0; $i<@line; $i++) {
+	if ($line[$i] =~ /^(\S+): blocks in use: (\d+), limits \(soft = (\d+), hard = (\d+)\)$/ && $mtab{$1} eq $_[1]) {
+		# found lines to change
+		$rv .= "$1: blocks in use: $2, limits (soft = $_[2], hard = $_[3])\n";
+		$line[++$i] =~ /^\s*inodes in use: (\d+), limits \(soft = (\d+), hard = (\d+)\)$/;
+		$rv .= "\tinodes in use: $1, limits (soft = $_[4], hard = $_[5])\n";
+		}
+	else { $rv .= "$line[$i]\n"; }
+	}
+return $rv;
+}
+
+# quotacheck(filesystem, mode)
+# Runs quotacheck on some filesystem
+sub quotacheck
+{
+$out = `$config{'quotacheck_command'} $_[0] 2>&1`;
+if ($?) { return $out; }
+return undef;
+}
+
+# copy_user_quota(user, [user]+)
+# Copy the quotas for some user to many others
+sub copy_user_quota
+{
+for($i=1; $i<@_; $i++) {
+	$out = `$config{'user_copy_command'} $_[0] $_[$i] 2>&1`;
+	if ($?) { return $out; }
+	}
+return undef;
+}
+
+# copy_group_quota(group, [group]+)
+# Copy the quotas for some group to many others
+sub copy_group_quota
+{
+for($i=1; $i<@_; $i++) {
+	$out = `$config{'group_copy_command'} $_[0] $_[$i] 2>&1`;
+	if ($?) { return $out; }
+	}
+return undef;
+}
+
+# get_user_grace(filesystem)
+# Returns an array containing  btime, bunits, ftime, funits
+# The units can be 0=sec, 1=min, 2=hour, 3=day
+sub get_user_grace
+{
+return &parse_grace_output($config{'user_grace_command'}, $_[0]);
+}
+
+# get_group_grace(filesystem)
+# Returns an array containing  btime, bunits, ftime, funits
+# The units can be 0=sec, 1=min, 2=hour, 3=day
+sub get_group_grace
+{
+return &parse_grace_output($config{'group_grace_command'}, $_[0]);
+}
+
+# default_grace()
+# Returns 0 if grace time can be 0, 1 if zero grace means default
+sub default_grace
+{
+return 0;
+}
+
+sub parse_grace_output
+{
+local(@rv, %mtab, @m);
+open(MTAB, "/etc/mtab");
+while(<MTAB>) { @m = split(/\s+/); $mtab{$m[0]} = $m[1]; }
+close(MTAB);
+$ENV{'EDITOR'} = $ENV{'VISUAL'} = "cat";
+open(GRACE, "$_[0] |");
+while(<GRACE>) {
+	if (/^(\S+): block grace period: (\d+) (\S+), file grace period: (\d+) (\S+)/ && $mtab{$1} eq $_[1]) {
+		@rv = ($2, $name_to_unit{$3}, $4, $name_to_unit{$5});
+		}
+	}
+close(GRACE);
+return @rv;
+}
+
+# edit_grace_file(data, filesystem, btime, bunits, ftime, funits)
+sub edit_grace_file
+{
+local($rv, $line, @m, %mtab);
+open(MTAB, "/etc/mtab");
+while(<MTAB>) { @m = split(/\s+/); $mtab{$m[0]} = $m[1]; }
+close(MTAB);
+foreach $line (split(/\n/, $_[0])) {
+	if ($line =~ /^(\S+): block grace period: (\d+) (\S+), file grace period: (\d+) (\S+)/ && $mtab{$1} eq $_[1]) {
+		# replace this line
+		$line = "$1: block grace period: $_[2] $unit_to_name{$_[3]}, file grace period: $_[4] $unit_to_name{$_[5]}";
+		}
+	$rv .= "$line\n";
+	}
+return $rv;
+}
+
+# grace_units()
+# Returns an array of possible units for grace periods
+sub grace_units
+{
+return ("Seconds", "Minutes", "Hours", "Days");
+}
+
+%name_to_unit = ( "second", 0, "seconds", 0,
+		  "minute", 1, "minutes", 1,
+		  "hour", 2, "hours", 2,
+		  "day", 3, "days", 3,
+		);
+foreach $k (keys %name_to_unit) {
+	$unit_to_name{$name_to_unit{$k}} = $k;
+	}
+
+1;
+
diff -uNr webmin-0.990.orig/raid/module.info webmin-0.990/raid/module.info
--- webmin-0.990.orig/raid/module.info	Mon Jul  1 07:04:42 2002
+++ webmin-0.990/raid/module.info	Mon Jul  1 11:24:29 2002
@@ -8,7 +8,7 @@
 desc_pt=RAID do Linux
 category=hardware
 desc_tr=Linux RAID
-os_support=redhat-linux mandrake-linux open-linux slackware-linux debian-linux suse-linux turbo-linux corel-linux cobalt-linux msc-linux generic-linux gentoo-linux
+os_support=redhat-linux mandrake-linux open-linux slackware-linux debian-linux suse-linux turbo-linux corel-linux cobalt-linux msc-linux generic-linux gentoo-linux pld-linux
 desc=Linux RAID
 desc_es=RAID de Linux
 desc_sv=Linux RAID
diff -uNr webmin-0.990.orig/samba/config-pld-linux webmin-0.990/samba/config-pld-linux
--- webmin-0.990.orig/samba/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/samba/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,12 @@
+list_printers_command=lpc status | grep "[A-z0-9]:" | sed -e 's/://g'
+smb_passwd=/etc/samba/smbpasswd
+dont_convert=root bin daemon adm lp sync shutdown halt mail news uucp operator games gopher ftp nobody postgres
+samba_password_program=/usr/bin/smbpasswd
+samba_status_program=/usr/bin/smbstatus
+samba_server=/usr/sbin/smbd
+name_server=/usr/sbin/nmbd
+smb_conf=/etc/samba/smb.conf
+text_lists=0
+run_from_inetd=0
+swat_path=/usr/sbin/swat
+sort_mode=0
diff -uNr webmin-0.990.orig/sendmail/config-pld-linux webmin-0.990/sendmail/config-pld-linux
--- webmin-0.990.orig/sendmail/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/sendmail/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,10 @@
+sendmail_cf=/etc/sendmail.cf
+sendmail_pid=/var/run/sendmail.pid
+makemap_path=makemap
+sendmail_command=/etc/rc.d/init.d/sendmail start
+sendmail_path=/usr/lib/sendmail
+mail_dir=/var/mail
+perpage=20
+sort_mode=0
+wrap_width=80
+order_mail=0
diff -uNr webmin-0.990.orig/software/config-pld-linux webmin-0.990/software/config-pld-linux
--- webmin-0.990.orig/software/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/software/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1 @@
+package_system=rpm
diff -uNr webmin-0.990.orig/squid/config-pld-linux webmin-0.990/squid/config-pld-linux
--- webmin-0.990.orig/squid/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/squid/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,8 @@
+log_dir=/var/log/squid
+squid_path=squid
+cache_dir=/var/cache/squid
+squid_conf=/etc/squid/squid.conf
+pid_file=/var/run/squid.pid
+cachemgr_path=/home/httpd/cgi-bin/cachemgr.cgi
+squid_start=/etc/rc.d/init.d/squid start
+squid_stop=/etc/rc.d/init.d/squid stop
diff -uNr webmin-0.990.orig/syslog/config-pld-linux webmin-0.990/syslog/config-pld-linux
--- webmin-0.990.orig/syslog/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/syslog/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,12 @@
+pri_all=1
+syslogd=/sbin/syslogd
+m4_conf=0
+syslog_conf=/etc/syslog.conf
+pri_dir=1
+pid_file=/var/run/syslogd.pid
+facilities=auth authpriv cron daemon kern lpr mail mark news syslog user uucp local0 local1 local2 local3 local4 local5 local6 local7
+m4_path=
+sync=1
+pipe=1
+tags=0
+lines=20
diff -uNr webmin-0.990.orig/time/module.info webmin-0.990/time/module.info
--- webmin-0.990.orig/time/module.info	Mon Jul  1 07:04:42 2002
+++ webmin-0.990/time/module.info	Mon Jul  1 11:25:15 2002
@@ -9,7 +9,7 @@
 desc_pt=Tempo do Sistema
 category=hardware
 desc_tr=Sistem Zaman
-os_support=redhat-linux mandrake-linux slackware-linux suse-linux debian-linux open-linux turbo-linux cobalt-linux solaris hpux macos freebsd netbsd msc-linux generic-linux openserver gentoo-linux
+os_support=redhat-linux mandrake-linux slackware-linux suse-linux debian-linux open-linux turbo-linux cobalt-linux solaris hpux macos freebsd netbsd msc-linux generic-linux openserver gentoo-linux pld-linux
 desc=System Time
 desc_es=Hora del Sistema
 desc_sv=Systemtid
diff -uNr webmin-0.990.orig/useradmin/config-pld-linux webmin-0.990/useradmin/config-pld-linux
--- webmin-0.990.orig/useradmin/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/useradmin/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,17 @@
+homedir_perms=0751
+display_max=400
+user_files=/etc/skel/C
+passwd_file=/etc/passwd
+post_command=
+group_file=/etc/group
+shadow_file=/etc/shadow
+gshadow_file=/etc/gshadow
+base_uid=1000
+base_gid=1000
+lock_string=*
+empty_mode=0
+sort_mode=0
+new_user_group=1
+skip_md5=0
+display_mode=1
+passwd_stars=0
diff -uNr webmin-0.990.orig/useradmin/pld-linux-lib.pl webmin-0.990/useradmin/pld-linux-lib.pl
--- webmin-0.990.orig/useradmin/pld-linux-lib.pl	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/useradmin/pld-linux-lib.pl	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,157 @@
+# linux-lib.pl
+# Functions for reading linux format last output
+
+# passfiles_type()
+# Returns 0 for old-style passwords (/etc/passwd only), 1 for FreeBSD-style
+# (/etc/master.passwd) and 2 for SysV (/etc/passwd & /etc/shadow)
+sub passfiles_type
+{
+return &password_file($config{'shadow_file'}) ? 2 : 0;
+}
+
+# groupfiles_type()
+# Returns 0 for normal group file (/etc/group only) and 2 for shadowed
+# (/etc/group and /etc/gshadow)
+sub groupfiles_type
+{
+return &password_file($config{'gshadow_file'}) ? 2 : 0;
+}
+
+# open_last_command(handle, user)
+sub open_last_command
+{
+local ($fh, $user) = @_;
+open($fh, "last $user |");
+}
+
+# read_last_line(handle)
+# Parses a line of output from last into an array of
+#  user, tty, host, login, logout, period
+sub read_last_line
+{
+$fh = $_[0];
+while(1) {
+	chop($line = <$fh>);
+	if (!$line) { return (); }
+	if ($line =~ /system boot/) { next; }
+	if ($line =~ /^(\S+)\s+(\S+)\s+(\S+)?\s+(\S+\s+\S+\s+\d+\s+\d+:\d+)\s+\-\s+(\S+)\s+\((\d+:\d+)\)/) {
+		return ($1, $2, $3, $4, $5 eq "down" ? "Shutdown" : $5, $6);
+		}
+	elsif ($line =~ /^(\S+)\s+(\S+)\s+(\S+)?\s+(\S+\s+\S+\s+\d+\s+\d+:\d+)\s+still/) {
+		return ($1, $2, $3, $4);
+		}
+	}
+}
+
+# encrypt_password(password)
+sub encrypt_password
+{
+local $md5 = 0;
+if (open(PAM, "/etc/pam.d/passwd")) {
+	while(<PAM>) {
+		s/#.*$//g;
+		$md5++ if (/^password.*md5/);
+		}
+	close(PAM);
+	}
+if (open(DEFS, "/etc/login.defs")) {
+	while(<DEFS>) {
+		s/#.*$//g;
+		$md5++ if (/MD5_CRYPT_ENAB\s+yes/i);
+		}
+	close(DEFS);
+	}
+if ($md5 && !$config{'skip_md5'}) {
+	# MD5 encrypt the password, using the same algorithm as PAM
+	eval "use MD5";
+	if ($@) {
+		&header("Error", "");
+		print "<hr><p>\n";
+		print "Your system has MD5 passwords enabled, but the perl\n",
+		      "MD5 module is not installed.<p> To force the use of\n",
+		      "normal encrypted passwords, adjust your\n",
+		      "<a href='/config.cgi?$module_name'>module ",
+		      "configuration</a>. <p><hr>\n";
+		exit;
+		}
+	local $passwd = $_[0];
+	local $magic = '$1$';
+	local $salt = substr(time(), -8);
+
+	# Add the password, magic and salt
+	local $ctx = new MD5;
+	$ctx->add($passwd);
+	$ctx->add($magic);
+	$ctx->add($salt);
+
+	# Add some more stuff from the hash of the password and salt
+	local $ctx1 = new MD5;
+	$ctx1->add($passwd);
+	$ctx1->add($salt);
+	$ctx1->add($passwd);
+	local $final = $ctx1->digest();
+	for($pl=length($passwd); $pl>0; $pl-=16) {
+		$ctx->add($pl > 16 ? $final : substr($final, 0, $pl));
+		}
+
+	# This piece of code seems rather pointless, but it's in the C code that
+	# does MD5 in PAM so it has to go in!
+	local $j = 0;
+	local ($i, $l);
+	for($i=length($passwd); $i; $i >>= 1) {
+		if ($i & 1) {
+			$ctx->add("\0");
+			}
+		else {
+			$ctx->add(substr($passwd, $j, 1));
+			}
+		}
+	$final = $ctx->digest();
+
+	# This loop exists only to waste time
+	for($i=0; $i<1000; $i++) {
+		$ctx1 = new MD5;
+		$ctx1->add($i & 1 ? $passwd : $final);
+		$ctx1->add($salt) if ($i % 3);
+		$ctx1->add($passwd) if ($i % 7);
+		$ctx1->add($i & 1 ? $final : $passwd);
+		$final = $ctx1->digest();
+		}
+
+	# Convert the 16-byte final string into a readable form
+	local $rv = $magic.$salt.'$';
+	local @final = map { ord($_) } split(//, $final);
+	$l = ($final[ 0]<<16) + ($final[ 6]<<8) + $final[12];
+	$rv .= &to64($l, 4);
+	$l = ($final[ 1]<<16) + ($final[ 7]<<8) + $final[13];
+	$rv .= &to64($l, 4);
+	$l = ($final[ 2]<<16) + ($final[ 8]<<8) + $final[14];
+	$rv .= &to64($l, 4);
+	$l = ($final[ 3]<<16) + ($final[ 9]<<8) + $final[15];
+	$rv .= &to64($l, 4);
+	$l = ($final[ 4]<<16) + ($final[10]<<8) + $final[ 5];
+	$rv .= &to64($l, 4);
+	$l = $final[11];
+	$rv .= &to64($l, 2);
+
+	return $rv;
+	}
+else {
+	local $salt = chr(int(rand(26))+65) . chr(int(rand(26))+65);
+	return crypt($_[0], $salt);
+	}
+}
+
+@itoa64 = split(//, "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
+sub to64
+{
+local ($v, $n) = @_;
+local $r;
+while(--$n >= 0) {
+        $r .= $itoa64[$v & 0x3f];
+        $v >>= 6;
+        }
+return $r;
+}
+
+1;
diff -uNr webmin-0.990.orig/wuftpd/config-pld-linux webmin-0.990/wuftpd/config-pld-linux
--- webmin-0.990.orig/wuftpd/config-pld-linux	Thu Jan  1 01:00:00 1970
+++ webmin-0.990/wuftpd/config-pld-linux	Mon Jul  1 11:15:43 2002
@@ -0,0 +1,7 @@
+ftpgroups=/etc/ftpgroups
+ftpd_path=/usr/sbin/wu.ftpd
+ftphosts=/etc/ftphosts
+ftpconversions=/etc/ftpconversions
+pid_file=/var/run/ftpd.pid
+ftpusers=/etc/ftpusers
+ftpaccess=/etc/ftpaccess
